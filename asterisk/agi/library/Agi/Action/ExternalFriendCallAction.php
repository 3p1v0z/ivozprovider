<?php

namespace Agi\Action;
use Ivoz\Provider\Domain\Model\Feature\Feature;

/**
 * @class ExternalFriendCallAction
 *
 * @brief Manage outgoing external calls generated by a friendly trunk
 *
 */
class ExternalFriendCallAction extends ExternalCallAction
{
    /**
     * @var integer
     */
    protected $_number;

    /**
     * @var boolean
     */
    protected $_checkACL;

    public function setDestination($number)
    {
        $this->_number = $number;
        return $this;
    }

    public function setCheckACL($acl)
    {
        $this->_checkACL = $acl;
        return $this;
    }

    public function process()
    {
        /** @var \Ivoz\Provider\Domain\Model\Friend\FriendInterface $friend */
        $friend = $this->agi->getChannelCaller();
        $number = $this->_number;

        // Get company from the caller
        $company = $friend->getCompany();

        // Some feedback for asterisk cli
        $this->agi->notice("Processing External call from \e[0;36m%s [friend%d]\e[0;93m to %s",
            $friend->getName(), $friend->getId(), $number);

        // Check if the diversion header contains a valid number
        $this->checkDiversionNumber($company, $number);

        // Check the user has this call allowed in its ACL
        if ($this->_checkACL && !$friend->isAllowedToCall($number)) {
            $this->agi->error("User is not allowed to call %s", $number);
            // Play error notification over progress
            if ($company->hasFeature(Feature::PROGRESS)) {
                $this->agi->progress("ivozprovider/notAllowed");
            }
            $this->agi->decline();
            return;
        }

        // Check if outgoing call can be tarificated
        if (!$this->checkTarificable($number)) {
            $this->agi->error("Destination %s can not be billed.", $number);
            // Play error notification over progress
            if ($company->hasFeature(Feature::PROGRESS)) {
                $this->agi->progress("ivozprovider/notBillable");
            }
            $this->agi->decline();
            return;
        }

        if (!isset($ddi)) {
            // Allow identification from any company DDI
            $callerIdNum = $this->agi->getCallerIdNum();
            $companyDDIs = $friend->getCompany()->getDDIs();
            foreach ($companyDDIs as $companyDDI) {
                if ($callerIdNum === $companyDDI->getDDIE164()) {
                    $this->agi->notice("Friend \e[0;36m%s [friend%d]\e[0;93m presented origin matches company DDI %s [ddi%d].",
                             $friend->getName(), $friend->getId(), $companyDDI->getDDIE164(), $companyDDI->getId());
                    $ddi = $companyDDI;
                    $this->agi->setCallerIdNum($ddi->getDDIE164());
                    break;
                }
            }
        }

        // Use fallback outgoing DDI
        if (!isset($ddi) || !$ddi) {
            $ddi = $friend->getOutgoingDDI();
            if ($ddi) {
                $this->agi->notice("Using fallback DDI %d [ddi%s] for friend \e[0;36m%s [friend%d]\e[0;93m because %s does not match any DDI.",
                    $ddi->getDDIE164(), $ddi->getId(), $friend->getname(), $friend->getId(), $callerIdNum);
                $this->agi->setCallerIdNum($ddi->getDDIE164());
            }
        }

        // Update caller displayed number
        if (!$ddi) {
            $this->agi->error("Friend %s [friend%d] has not OutgoingDDI configured",  $friend->getName(), $friend->getId());
            $this->agi->decline();
            return;
        }

        // Check if DDI has recordings enabled
        $this->checkDDIRecording($ddi);
        // Check if DDI belong to platform
        $this->checkDDIBounced($number);


        // Call the PSJIP endpoint
        $this->agi->setVariable("DIAL_DST", "PJSIP/" . $number . '@proxytrunks');
        $this->agi->setVariable("DIAL_OPTS", "");
        $this->agi->setVariable("DIAL_TIMEOUT", "");
        $this->agi->redirect('call-world', $number);
    }
}

<?php

namespace Ivoz\Kam\Infrastructure\Persistence\Doctrine;

use Doctrine\Common\Collections\Criteria;
use Doctrine\ORM\EntityRepository;
use Ivoz\Kam\Domain\Model\AccCdr\AccCdrInterface;
use Ivoz\Kam\Domain\Model\AccCdr\AccCdrRepository;

/**
 * AccCdrDoctrineRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class AccCdrDoctrineRepository extends EntityRepository implements AccCdrRepository
{
    const ENTITY_ALIAS = 'accCdr';

    /**
     * @inheritDoc
     */
    public function fetchUntarificattedCallNumber(
        int $companyId,
        int $brandId,
        string $startTime,
        int $metered
    ) {
        $querySegments = [
            self::ENTITY_ALIAS . '.company = :companyId',
            self::ENTITY_ALIAS . '.brand = :brandId',
            self::ENTITY_ALIAS . '.startTime <= :startTime',
            self::ENTITY_ALIAS . '.metered = :metered'
        ];

        $querySegments += $this->getEmptyPeeringContractFilterQueryArguments(self::ENTITY_ALIAS);
        $query = implode(' AND ', $querySegments);
        $queryArguments = [
            'companyId' => $companyId,
            'brandId' => $brandId,
            'startTime' => $startTime,
            'metered' => $metered
        ];

        $qb = $this->createQueryBuilder(self::ENTITY_ALIAS);
        $qb->select('count(' . self::ENTITY_ALIAS  . ')')
           ->where($query)
           ->setParameters($queryArguments);

        return $qb
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * @inheritDoc
     */
    public function fetchTarificableList(
        int $companyId,
        int $brandId,
        string $startTime,
        string $utcNextInvoiceInDate
    ) {
        $querySegments = [
            self::ENTITY_ALIAS . '.company = :companyId',
            self::ENTITY_ALIAS . '.brand = :brandId',
            self::ENTITY_ALIAS . '.startTime > :startTime',
            self::ENTITY_ALIAS . '.startTime < :utcNextInvoiceInDate'
        ];

        $querySegments += $this->getEmptyPeeringContractFilterQueryArguments(self::ENTITY_ALIAS);
        $query = implode(' AND ', $querySegments);
        $queryArguments = [
            'companyId' => $companyId,
            'brandId' => $brandId,
            'startTime' => $startTime,
            'utcNextInvoiceInDate' => $utcNextInvoiceInDate
        ];

        $qb = $this->createQueryBuilder(self::ENTITY_ALIAS);
        $qb->select(self::ENTITY_ALIAS)
            ->where($query)
            ->setParameters($queryArguments);

        return $qb
            ->getQuery()
            ->getResult();
    }


    /**
     * @inheritDoc
     */
    public function countTarificableByQuery(array $criteria)
    {
        /**
         * @todo
         */
        throw new \Exception('TODO');
        $criteria += $this->getEmptyPeeringContractFilterQueryArguments();

        /**
         * @todo ensure that criteria arguments are handled properly
         */
        $qb = $this->createQueryBuilder(self::ENTITY_ALIAS);
        $qb->select('count(' . self::ENTITY_ALIAS  . ')')
            ->addCriteria(new Criteria($criteria));

        return $qb
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * @return array
     */
    public function getEmptyPeeringContractFilterQueryArguments($alias)
    {
        return [
            $alias . '.peeringContract != NULL',
            $alias . '.peeringContract != ""'
        ];
    }
}

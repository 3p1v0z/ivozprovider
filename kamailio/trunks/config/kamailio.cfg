#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define XMLRPC_PORT 8000

# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags
 
# ACC Flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3

# DLG_FLAG
#!define DLG_FLAG 4

# Set when processing REINVITE to skip some logics on answers
#!define FLT_REINVITE 5

# RELATED Flag (when set, aleg found for this call in this proxy)
#!define FLT_ISBLEG 6

# - options

#!define WITH_ANTIFLOOD

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

# FIXME Hacer que tire de IP que no hay forma :(
#!define CONTACT "5.196.32.135:5060"

####### Global Parameters #########

listen=udp:IP:5060
listen=tcp:IP:5060
listen=tcp:IP:5061
listen=tcp:IP:XMLRPC_PORT

# -- Debug level
debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 0 desc "If 1, log invite transactions"
dolog.register  = 0 desc "If 1, log register transactions"
dolog.publish   = 0 desc "If 1, log publish transactions"
dolog.subscribe = 0 desc "If 1, log subscribe transactions"
dolog.notify    = 0 desc "If 1, log notify transactions"
dolog.options   = 0 desc "If 1, log options transactions"
dolog.message   = 0 desc "If 1, log message transactions"
dolog.refer     = 0 desc "If 1, log refer transactions"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "sqlops.so"
loadmodule    "rtpengine.so"
loadmodule    "cfg_rpc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "acc.so"
loadmodule    "lcr.so"
loadmodule    "uac.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpc-s.so"
loadmodule    "json.so"
loadmodule    "domain.so"
loadmodule    "cfgutils.so"
loadmodule    "dialplan.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_SOCK)")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")

# TLS
modparam("tls", "config", "/etc/kamailio/proxytrunks/tls.cfg")

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxytrunks_fifo")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# El parametro clave es debug (por defecto a 2 en este cfg)
# Se imprime todo lo que tenga <= que este valor (valores posibles: 0 - infinito)
# 0: De WARN (incluido) para arriba
# 1: De NOTICE (incluido) para arriba
# 2: De INFO (incluido) para arriba
# 3: De DBG (incluido) para arriba
# 
# Se puede modificar on-the-fly con:
# kamcmd cfg.seti core debug X
# Y obtener el valor actual con:
# kamcmd cfg.get core debug

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxytrunks_ctl")

# RTPENGINE
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:22223")

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# ACC
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "db_url", DBURL)
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 0) 
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "acc_time_column", "localtime")

# -- to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd")

# -- to database
modparam("acc", "db_table_acc", "kam_trunks_acc")
modparam("acc", "db_table_missed_calls", "kam_trunks_missed_calls")
modparam("acc", "cdrs_table", "kam_trunks_acc_cdrs")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd; cseq=$cs")
#modparam("acc", "multi_leg_info",
#    "leg_src=$avp(src);leg_dst=$avp(dst)")

# -- cdr accounting
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "companyId=$dlg_var(companyId);companyName=$dlg_var(companyName);caller=$dlg_var(caller);callee=$dlg_var(callee);type=$dlg_var(type);callid=$dlg_var(callid);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion)")
modparam("acc", "cdr_start_on_confirmed", 1)

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_no_value", "entrante ; saliente")
modparam("dialog", "profiles_with_value", "companyId; externalMaxCalls")
# Destruye dialogo si no hay BYE (se reinicia a cada request)
#modparam("dialog", "default_timeout", 21600)
#modparam("dialog", "default_timeout", 90)
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
# Las incluye en mensajes creados por el modulo dialog (BYEs)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n")
# Keep-alive (in-dialog OPTIONs)
#modparam("dialog", "ka_timer", 10)
#modparam("dialog", "ka_interval", 300)
# Interesante para: uac_auth()
modparam("dialog", "track_cseq_updates", 1)

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;dbtable=kam_trunks_htable")
#!endif

modparam("htable", "htable", "dialogs=>size=10;autoexpire=0;dbtable=kam_trunks_htable")

# UAC
modparam("uac", "auth_realm_avp","$avp(realm)")
modparam("uac", "auth_username_avp","$avp(provideruser)")
modparam("uac", "auth_password_avp","$avp(secret)")
modparam("uac", "restore_mode","auto")
modparam("uac", "restore_dlg", 1)
modparam("uac", "reg_db_url", DBURL)
modparam("uac", "reg_db_table", "kam_trunks_uacreg")
modparam("uac", "reg_contact_addr", CONTACT)

# LCR
modparam("lcr", "db_url", DBURL)
modparam("lcr", "lcr_gw_table","LcrGateways")
modparam("lcr", "lcr_rule_table", "LcrRules")
modparam("lcr", "lcr_rule_target_table", "LcrRuleTargets")
modparam("lcr", "gw_name_column", "gw_name")
modparam("lcr", "ip_addr_column", "ip")
modparam("lcr", "lcr_id_column", "companyId")
modparam("lcr", "gw_uri_avp", "$avp(i:709)")
modparam("lcr", "ruri_user_avp", "$avp(i:500)")
modparam("lcr", "tag_avp", "$avp(lcr_tag)")
modparam("lcr", "flags_avp", "$avp(s:caller_method)")
modparam("lcr", "defunct_capability", 1)
modparam("lcr", "lcr_id_avp", "$avp(lcr_id_avp)")
modparam("lcr", "defunct_gw_avp", "$avp(defunct_gw_avp)")
modparam("lcr", "lcr_rule_hash_size", 1024)
modparam("lcr", "lcr_gw_count", 1024)
#modparam("lcr", "dont_strip_or_tag_flag", WTF)
modparam("lcr", "fetch_rows", 3000)
modparam("lcr", "ping_interval", 15) # Ping every 15 seconds
modparam("lcr", "ping_inactivate_threshold", 1) # Mark as inactive at first call of inactivate_gw()
modparam("lcr", "ping_valid_reply_codes", "403,404,405,501") # Mark as active when 2XX or these reply codes
modparam("lcr", "ping_from", "sip:pinger@localhost")
modparam("lcr", "lcr_count", 10)

# TM
modparam("tm", "fr_timer", 5000)

# AVPOPS
modparam("avpops", "db_url", DBURL)
modparam("avpops","avp_table","kam_trunks_usr_preferences")
modparam("avpops", "use_domain", 1)

# SANITY
modparam("sanity", "autodrop", 0)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_trunks_domain")
modparam("domain", "domain_attrs_table", "kam_trunks_domain_attrs")
modparam("domain", "register_myself", 1)

# DIALPLAN
modparam("dialplan", "db_url", DBURL)
modparam("dialplan", "table_name", "kam_trunks_dialplan")
modparam("dialplan", "attrs_pvar", "$avp(s:appliedrule)")

####### Routing Logic ########

request_route {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE","Request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        if ($dlg_var(log)) xlog("L_NOTICE","Send 200 to '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");
        send_reply("200", "I'm here!");
        exit;
    }

    # per request initial checks
    route(REQINIT);

    # Setup accounting
    route(ACCOUNTING);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO","----> $rm from $si\n");

        if (t_check_trans())
            route(RELAY);

        exit;
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO","In dialog request - has_to_tag\n");
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    if ($dlg_var(log)) xlog("L_INFO","NOT in dialog request - not has_to_tag: Initial transaction\n");

    # Manage retransmissions
    t_check_trans();

    # Only INVITE can start a dialog
    if (!is_method("INVITE")) {
        if ($dlg_var(log)) xlog("L_WARN","$rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Remove preloaded route headers
    if ($dlg_var(log)) xlog("L_INFO", "Remove preloaded route headers\n");
    remove_hf("Route");

    # Manage dialog and set session-timers flag
    if ($dlg_var(log)) xlog("L_INFO", "dialog_manage()\n");
    dlg_manage();
    #dlg_set_property("ka-src");
    #dlg_set_property("ka-dst");

    # Add record-route to INVITE requests
    if ($dlg_var(log)) xlog("L_INFO","Add record-route");
    record_route();

    # Easy routing:
    # (a) From GWs ----> Choose AS
    # (b) From ASs ----> Choose GW
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "Source: Known AS, route to corresponding GW\n");

        # Remove 100rel extension capability added by Asterisk 13
        route(REMOVE_100REL);

        # AS provides needed info in X-INFO header
        route(PARSE_X_HEADERS);
        route(CONTROL_EXTERNAL_MAXCALLS);
        route(PROFILE_OUTBOUND_CALL);

        # Guess if this call is related to another one (due to call forward?)
        if ($dlg_var(log)) xlog("L_INFO", "Guess if this call is related to another one (due to call forward?)\n");
        route(RELATE_LEGS);

        # Route wisely
        route(CHOOSE_GW);
        t_on_failure("MANAGE_FAILURE_GW"); # Ruta de fallo propia para llamadas a GW
        t_on_branch("MANAGE_BRANCH_GW");   # Ruta de branch propia para llamadas a GW
    } else if (from_gw("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "Source: Provider, route to corresponding AS\n");

        # X-HEADERS are for internal use only, they shouldn't be added by trunks
        remove_hf_re("^X-");

        if ($dlg_var(log)) xlog("L_INFO", "Invoke DIALOGS_GET_INFO for initial INVITE from GW ($ci)\n");
        route(DIALOGS_GET_INFO);
        route(GET_INFO_FROM_DID);
        route(CONTROL_EXTERNAL_MAXCALLS);
        route(GET_INFO_FROM_SOURCE_ADDRESS);
        route(TRANSFORMATE_CALLER_IN);
        route(TRANSFORMATE_CALLEE_IN);
        route(PROFILE_INBOUND_CALL);
        route(DISPATCH);
    } else {
        if ($dlg_var(log)) xlog("L_ERR","Request from non-AS and non-GW, 403\n");
        send_reply("403", "Forbidden");
        exit;
    }

    route(RELAY);
}

route[REMOVE_100REL] {
    if ($dlg_var(log)) xlog("L_INFO", "Remove 100rel extension capability added by Asterisk 13\n");
    if(is_present_hf("Supported")) {
        replace_all("100rel, ", "");
        replace_all("100rel", "");
    }
}

route[CHOOSE_GW] {
    # Para saber que GWs matchean, se mira el RURI-User y el URI del llamante
    # El URI del llamante se puede coger de muchos sitios (From, PAI, RPID...)
    # (de momento, del From)
    $avp(caller_uri) = $fu;

    # Cargar GWs dentro del grupo lcr_id que no esten defunct
    # El primer campo es el lcr_id. Cada empresa tendra su lcr_id unico (que coincida con companyId, e.g.)
    # que hace que solo se tengan en cuenta las rutas que puede usar esa empresa
    # El 0 es un lcr_id especial que aplica a todas las empresas (rutas para llamadas de emergencia?)
    if (!load_gws($dlg_var(companyId), $rU, $avp(caller_uri))) {
        # No matchea nada, no puedo sacar la llamada
        if ($dlg_var(log)) xlog("L_ERR", "Cannot load gateways\n");
        sl_send_reply("500", "Server Internal Error - Cannot load gateways");
        exit;
    } else {
        # Al menos un gateway disponible, sigo adelante
        if ($dlg_var(log)) xlog("L_INFO", "Gateways loaded, evaluate rules!\n");    
        route(FIRSTGW);
    }
}

route[FIRSTGW] {
    # La seleccion del GW modifica RURI y Dest-URI, logo antes y despues
    # -- antes --
    if ($dlg_var(log)) xlog("L_INFO", "FIRSTGW: Antes: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "FIRSTGW: Antes: RURI $ru\n");

    # Selecciono GW evaluando reglas
    if (!next_gw()) {
        if ($dlg_var(log)) xlog("L_ERR", "FIRSTGW: NO next GW");
        sl_send_reply("503", "Service not available - No gateways");
        exit;
    }

    # -- despues --
    if ($dlg_var(log)) xlog("L_INFO", "FIRSTGW: Despues: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "FIRSTGW: Despues: RURI $ru\n");

    # Guardo valores para volver a setear en caso de 401/407 (ver FAILURE_ROUTE)
    $avp(nextgwruri) = $ru;
    $avp(nextgwdu) = $du;
    
    # Utilizo lcr_tag del GW para guardar el auth_username:auth_passward
    # Meto los valores en los AVP-s que lee UAC
    $avp(provideruser) = $(avp(lcr_tag){s.select,0,:});
    $avp(secret) = $(avp(lcr_tag){s.select,1,:});
}

route[NEXTGW] {
    # La seleccion del GW modifica RURI y Dest-URI, logo antes y despues
    # -- antes --
    if ($dlg_var(log)) xlog("L_INFO", "NEXTGW: Antes: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "NEXTGW: Antes: RURI $ru\n");

    # Selecciono GW evaluando reglas
    if (!next_gw()) {
        if ($dlg_var(log)) xlog("L_ERR", "NEXTGW: NO next GW, send current response");
        exit;
    }

    # -- despues --
    if ($dlg_var(log)) xlog("L_INFO", "NEXTGW: Despues: Dest-URI $du\n");
    if ($dlg_var(log)) xlog("L_INFO", "NEXTGW: Despues: RURI $ru\n");

    # Guardo valores para volver a setear en caso de 401/407 (ver FAILURE_ROUTE)
    $avp(nextgwruri) = $ru;
    $avp(nextgwdu) = $du;
    
    # Utilizo lcr_tag del GW para guardar el auth_username:auth_passward
    # Meto los valores en los AVP-s que lee UAC
    $avp(provideruser) = $(avp(lcr_tag){s.select,0,:});
    $avp(secret) = $(avp(lcr_tag){s.select,1,:});
}

route[PARSE_X_HEADERS] {
    if ($dlg_var(log)) xlog("L_INFO", "PARSE-X-HEADERS: Set call_type to 'saliente'\n");
    $dlg_var(type) = 'saliente';

    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract externalMaxCalls
    $var(header) = 'X-Info-MaxCalls';
    route(PARSE_X_HEADER);
    $dlg_var(externalMaxCalls) = $var(header-value);
}

route[PARSE_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "PARSE-X-HEADER: $var(header): $hdr($var(header))\n");
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "PARSE-X-HEADER: $var(header) not present or not valid, aborting\n");
        sl_send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[PROFILE_OUTBOUND_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "PROFILE-OUTBOUND-CALL: saliente\n");
    $dlg_var(type) = "saliente";
    set_dlg_profile("saliente");

    # Llamadas salientes activas
    if(get_profile_size("saliente","$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-OUTBOUND-CALL: currently there are $avp(size) outbound calls\n");
    }

    # Activity calls by company
    set_dlg_profile("companyId","$dlg_var(companyId)");
    if(get_profile_size("companyId","$dlg_var(companyId)","$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-OUTBOUND-CALL: currently, the companyId '$dlg_var(companyName)' has $avp(size) outbound active calls\n");
    }
}

route[GET_INFO_FROM_DID] {
    # Esta info se saca de BBDD partiendo del DDI al que entra la llamada
    sql_xquery("cb", "SELECT c.name AS companyName, c.id AS companyId, b.id AS brandId, c.externalMaxCalls, d.routeType, CS.calling_code AS company_cc FROM DDIs d JOIN Companies c ON d.companyId=c.id LEFT JOIN Brands b ON b.id=c.brandId LEFT JOIN Countries CS ON CS.Id=c.countryId WHERE d.DDI='$rU'", "ra");

    sql_result_free("ra");

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-DID: companyId: $xavp(ra=>companyId)\n");
    $dlg_var(companyId) = $xavp(ra=>companyId);
    if ($dlg_var(companyId) == $null) {
        if ($dlg_var(log)) xlog("L_WARN", "GET-INFO-FROM-DID: DID $rU not assigned to any Company, 404 Not Found\n");
        send_reply("404", "Not Found");
        exit;
    }

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-DID: companyName: $xavp(ra=>companyName)\n");
    $dlg_var(companyName) = $xavp(ra=>companyName);

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-DID: brandId: $xavp(ra=>brandId)\n");
    $avp(brandId) = $xavp(ra=>brandId);

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-DID: externalMaxCalls: $xavp(ra=>externalMaxCalls)\n");
    $avp(externalMaxCalls) = $xavp(ra=>externalMaxCalls);

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-DID: routeType: $xavp(ra=>routeType)\n");
    $dlg_var(routeType) = $xavp(ra=>routeType);

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-DID: company_cc: $xavp(ra=>company_cc)\n");
    $dlg_var(company_cc) = $xavp(ra=>company_cc);
    if ($dlg_var(company_cc) == $null) {
        if ($dlg_var(log)) xlog("L_WARN", "GET-INFO-FROM-DID: company_cc not set, set to default calling code (spain, 34)\n");
        $dlg_var(company_cc) = 34;
    }
}

route[GET_INFO_FROM_SOURCE_ADDRESS] {
    # Esta info se saca de BBDD partiendo del GW desde el que entra la llamada
    sql_xquery("cb", "SELECT TRAN.caller_in, TRAN.callee_in FROM PeerServers PS LEFT JOIN PeeringContracts PC ON PC.id=PS.peeringContractId LEFT JOIN TransformationRulesetGroupsTrunks TRAN ON TRAN.id=PC.transformationRulesetGroupsTrunksId WHERE ip='$si' AND PS.brandId='$avp(brandId)'", "ra");

    sql_result_free("ra");

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-SOURCE-ADDRESS: caller_in: $xavp(ra=>caller_in)\n");
    $avp(caller_in) = $xavp(ra=>caller_in);


    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-SOURCE-ADDRESS: callee_in: $xavp(ra=>callee_in)\n");
    $avp(callee_in) = $xavp(ra=>callee_in);
}

route[PROFILE_INBOUND_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "PROFILE-INBOUND-CALL: entrante\n");
    $dlg_var(type) = "entrante";
    set_dlg_profile("entrante");

    # Llamadas entrantes activas
    if(get_profile_size("entrante","$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-INBOUND-CALL: currently there are $avp(size) inbound calls\n");
    }
}

# Handle within-dialog messages
route[WITHINDLG] {
    # Set FLT_REINVITE if within dialog invite (reinvite)
    if (is_method("INVITE")) {
        if ($dlg_var(log)) xlog("L_INFO", "WITHINDLG: Setting FLT_REINVITE flag\n");
        setflag(FLT_REINVITE);
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        sl_send_reply("403","Not here");
    }
    exit;
}

route[DISPATCH] {
    # round robin dispatching on ASs
    if(!ds_select_dst("1", "4")) {
        if ($dlg_var(log)) xlog("L_ERR", "DISPATCH: No destination found\n");
        send_reply("404", "No destination");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "DISPATCH: going to <$ru> via <$du>\n");
    t_on_failure("MANAGE_FAILURE_AS");
    route(RELAY);
}

# Relay request
route[RELAY] {
    if ($(du{uri.host}) != $null)
        if ($dlg_var(log)) xlog("L_INFO", "RELAY: Relaying to $(du{uri.host}) (du, $dP)\n");
    else
        if ($dlg_var(log)) xlog("L_INFO", "RELAY: Relaying to $(ru{uri.host}) (ru)\n");

    if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    if(!t_is_set("branch_route"))  t_on_branch("MANAGE_BRANCH");
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

# Initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    # flood dection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself && !ds_is_from_list("1")) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            if ($dlg_var(log)) xlog("L_ERR", "REQINIT: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            if ($dlg_var(log)) xlog("L_ERR","REQINIT: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
#!endif

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        if ($dlg_var(log)) xlog("L_ERR", "REQINIT: Too many hops for SIP message from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        if ($dlg_var(log)) xlog("L_ERR", "REQINIT: Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Easy dropping for sipvicious scans
    if (search("sipvicious")) {
        if ($dlg_var(log)) xlog("L_WARN","REQINIT: DROPPED SIPVICIOUS ----> $rm from $si\n");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "REQINIT: All checks passed, continue...\n");
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    return;
}

route[DIALOGS_GET_INFO] {
    if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Set source_ip to $si\n");
    $sht(dialogs=>$ci::source_ip) = $si;

    if (sdp_content()) {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Has SDP, check por m= and c= lines\n");

        if(sdp_get_line_startswith("$avp(cline)", "c=")) {
            if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Set media_ip to $(avp(cline){s.select,2, })\n");
            $sht(dialogs=>$ci::media_ip) = $(avp(cline){s.select,2, });
        }

        if (sdp_get_line_startswith("$avp(mline)", "m=")) {
            if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Set media_port to $(avp(mline){s.select,1, })\n");
            $sht(dialogs=>$ci::media_port) = $(avp(mline){s.select,1, });
        }
    }
}

route[RELATE_LEGS] {
    if ($sht(dialogs=>$dlg_var(xcallid)::source_ip) != '') {
        if ($dlg_var(log)) xlog("L_INFO", "RELATE-LEGS: $ci aleg is $dlg_var(xcallid), set FLT-ISBLEG\n");
        setflag(FLT_ISBLEG);
        $sht(dialogs=>$ci::aleg) = $dlg_var(xcallid);

        if ($dlg_var(log)) xlog("L_INFO", "RELATE-LEGS: $dlg_var(xcallid) bleg is $ci\n");
        $sht(dialogs=>$dlg_var(xcallid)::bleg) = $ci;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "RELATE-LEGS: $dlg_var(xcallid) not present in dialogs htable, skip\n");
    }
}

route[DIALOGS_COPY_INFO] {
    # If aleg found for this dialog, copy keys from each one to another
    if (isflagset(FLT_ISBLEG)) {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: aleg found for $ci, copy remote keys and vice versa\n");
        $avp(aleg) = $sht(dialogs=>$ci::aleg);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: aleg not found for $ci, return\n");
        return;
    }

    # Copy leg1 ($avp(aleg)) info to leg2 ($ci) with remote prefix
    $sht(dialogs=>$ci::remote_source_ip) = $sht(dialogs=>$avp(aleg)::source_ip);
    $sht(dialogs=>$ci::remote_media_ip) = $sht(dialogs=>$avp(aleg)::media_ip);
    $sht(dialogs=>$ci::remote_media_port) = $sht(dialogs=>$avp(aleg)::media_port);

    # Copy leg2 ($ci) info to leg1 ($avp(aleg)) with remote prefix
    $sht(dialogs=>$avp(aleg)::remote_source_ip) = $sht(dialogs=>$ci::source_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_ip) = $sht(dialogs=>$ci::media_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_port) = $sht(dialogs=>$ci::media_port);

    # Try to guest if directmedia seems possible
    if ($sht(dialogs=>$ci::source_ip) == $sht(dialogs=>$ci::remote_source_ip)) {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: Source IP of both endpoints is equal, directmedia seems legit\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: Source IP of both endpoints is NOT equal, directmedia NOT possible\n");
    }
}

route[ACCOUNTING] {
    if (!is_method("INVITE|BYE|CANCEL"))
        return;

    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED);

    if (is_method("INVITE")) {
        setflag(FLT_ACCMISSED);
        if (!has_totag()) {
            # Get info from initial request only
            $dlg_var(caller) = $fU;
            $dlg_var(callee) = $rU;
            $dlg_var(callid) = $ci;
            if (is_present_hf("Diversion"))
                $dlg_var(diversion) = $(di{uri.user});
        }
    }
}

# Reply generic route (all replies goes through this route)
onreply_route {
    route(CONFIGURE_XLOG);
    if ($dlg_var(log)) xlog("L_NOTICE","Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO","MANAGE_REPLY: rtpengine_manage\n");
    rtpengine_manage("ICE=remove");
}

# Manage failure replies (only for failure response codes, executed after previous 2 routes)

# -- Failure route for GWs
failure_route[MANAGE_FAILURE_GW] {
    if ($dlg_var(log)) xlog("L_WARN","MANAGE-FAILURE-GW: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_WARN","MANAGE-FAILURE-GW: t_is_canceled, exit here\n");
        exit;
    }

    if (isflagset(FLT_REINVITE)) {
        if ($dlg_var(log)) xlog("L_INFO","MANAGE-FAILURE-GW: Skip block logic as it is an error answer to a REINVITE\n");
        exit;
    }

    if (t_check_status("(401)|(407)")) {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE-GW: $T_reply_code al canto, hay que hacer auth con este provider!\n");

        # Cosa rara de cojones: cuando llega un 401/407 despues de haber hecho un balanceo a otro GW porque el primero
        # no responde, se hereda $du y $ru del primer branch (del fallido). Esto provoca que el INVITE con auth que genera
        # uac_auth() no se mande al segundo GW, sino al primero (que ya esta fuera de todo esto).
        # Solucion temporal despues de volverme loco: resetear du y ru a los valores obtenidos en la ultima invocacion a NEXTGW
        $du = $avp(nextgwdu);
        $ru = $avp(nextgwruri);

        # Nos preparamos para la autenticacion
        #   username:  lo recoge de $avp(provideruser) seteado en NEXTGW
        #   password:  la recoge de $avp(secret) tirando de DB, mas abajo
        #   realm:     la recoge del 401/407 seteando a ''
        $avp(realm) = '';

        # Si $avp(secret) se ha seteado, tenemos credenciales para intentar autenticacion
        if (is_avp_set("$avp(secret)")) {
            if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE-GW: Secret loaded from AVP, sounds good\n");
            # Envia INVITE con AUTH (y fakea CSeq)
            uac_auth();
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "No secret available for $avp(newfrom), defunct_gw and try another one\n");
            defunct_gw(36000); # No credentials available, defunct gw 4ever and trigger alarm
            route(NEXTGW);
        }
    # FIXME: Which reply codes should avoid failover?
    } else if (t_check_status("486")) {
        if ($dlg_var(log)) xlog("L_INFO", "Destiny busy (reply code: $T_reply_code)\n");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "Error al sacar la llamada (reply code: $T_reply_code)\n");
        # FIXME: Which reply codes should inactivate current GW??
        if (t_check_status("408")) {
            if ($dlg_var(log)) xlog("L_WARN", "$T_reply_code: Inactivate GW\n");
            inactivate_gw(); # Inactivate GW temporally (until it answers OPTIONS)
        }
        if ($dlg_var(log)) xlog("L_INFO", "Try next GW\n");
        route(NEXTGW);
    }

    t_on_failure("MANAGE_FAILURE_GW"); # Ruta de fallo propia para llamadas a GW
    t_on_branch("MANAGE_BRANCH_GW");   # Ruta de branch propia para llamadas a GW
    route(RELAY);
}

failure_route[MANAGE_FAILURE] {
    if ($dlg_var(log)) xlog("L_WARN","MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ($dlg_var(log)) xlog("L_ERR","MANAGE-FAILURE: This route should NOT be used, main logic error\n");
    exit;
}

failure_route[MANAGE_FAILURE_AS] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    if (isflagset(FLT_REINVITE)) {
        if ($dlg_var(log)) xlog("L_INFO","MANAGE-FAILURE-AS: Skip block logic as it is an error answer to a REINVITE\n");
        return;
    }

    # next DST - only for 500 or local timeout
    if (t_check_status("500") or (t_branch_timeout() and !t_branch_replied())) {
        ds_mark_dst("ip");
        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    # AS responde algo inesperado, abortamos failover y enviamos 408 Timeout
    if ($dlg_var(log)) xlog("L_ERR","MANAGE-FAILURE-AS: Something went wrong, AS seems bugged!\n");
    exit;
}

# Route for branching to GWs: Only for INVITEs and BYEs (fork-able)

# -- Branch route for GWs
branch_route[MANAGE_BRANCH_GW] {
    if ($dlg_var(log)) xlog("L_WARN","MANAGE_BRANCH_GW: New branch [$T_branch_idx] to $ru\n");

    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO","MANAGE_BRANCH_GW: rtpengine_manage\n");
    rtpengine_manage("ICE=remove");

    # In initial request, adapt From, To, PAI and RPID to what selected gateway expects
    if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Adapt From, To, PAI and RPID to what selected gateway expects\n");

    # avp(caller_method): bitwise flag ABC (in DB integer from 0-7)
    # A: auth_username as from_user flag (4)
    # B: RPID flag (2)
    # C: PAI flag (1)
    #
    # e.g. 5: Use auth_username as from_user and use PAI header

    # FIXME: Remove pre-existing RPID and PAI header (es correcto esto o rompe actualizaciones de callerid?)

    # Asterisk must send PAI header when talking to proxytrunks
    if (is_present_hf("P-Asserted-Identity")) {
        # PAI should be equal to From
        if ($ai == $fu)
            if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: PAI URI is equal to From URI, seems legit\n");
        else
            if ($dlg_var(log)) xlog("L_ERR", "MANAGE_BRANCH_GW: PAI URI ($ai) is DIFFERENT from From URI ($fu), this should NEVER happen\n");

        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Remove P-Asserted-Identity\n");
        remove_hf("P-Asserted-Identity");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "MANAGE_BRANCH_GW: No P-Asserted-Identity header, this should NEVER happen\n");
    }

    # Asterisk should never send RPID header when talking to proxytrunks
    if (is_present_hf("Remote-Party-ID")) {
        if ($dlg_var(log)) xlog("L_ERR", "MANAGE_BRANCH_GW: Remote-Party-ID found, this should NEVER happen\n");
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Remove Remote-Party-ID\n");
        remove_hf("Remote-Party-ID");
    }

    # newfrom is equal to current From URI unless it is overriden
    $avp(newfrom) = $fu;

    # Use PAI?
    if (avp_check("$avp(caller_method)", "and/i:0x01")) {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Copy from_user to PAI header\n");
        append_hf("P-Asserted-Identity: \"$fU\" <$fu>\r\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Do not use PAI\n");
    }

    # Use RPID?
    if (avp_check("$avp(caller_method)", "and/i:0x02")) {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Copy from_user to RPID header\n");
        append_hf("Remote-Party-ID: \"$fU\" <$fu>;privacy=off;screen=no");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Do not use RPID\n");
    }

    # Use auth_username as from_user?
    if (avp_check("$avp(caller_method)", "and/i:0x04")) {
        # Override from_user with auth_username
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Use auth_username as from_user\n");
        $avp(newfrom) = "sip:" + $avp(provideruser) + '@' + $rd; # Change username to GW SIP username
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: Do not use auth_username as from_user\n");
    }

    if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: New from: \"$fU\" <$avp(newfrom)>\n");
    uac_replace_from('"$fU"', "$avp(newfrom)"); # Cambio el From (se auto cambiara en la respuesta)

    # To should be equal to RURI
    $avp(newto) = $ru;
    if ($dlg_var(log)) xlog("L_INFO", "MANAGE_BRANCH_GW: New to: $avp(newto)\n");
    uac_replace_to("$avp(newto)"); # Cambio el To (se auto cambiara en la respuesta)
}

# -- Branch route for ASs
branch_route[MANAGE_BRANCH] {
    if ($dlg_var(log)) xlog("L_WARN","MANAGE_BRANCH: New branch [$T_branch_idx] to $ru\n");

    # Manage RTP
    if ($dlg_var(log)) xlog("L_INFO","MANAGE_BRANCH: rtpengine_manage\n");
    rtpengine_manage("ICE=remove");
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if (from_gw($dlg_var(companyId))) {
        # Call to DIALOGS_GET_INFO and DIALOGS_COPY_INFO only for 200 OK from GW
        if ($dlg_var(log)) xlog("L_INFO", "200 OK from GW, outgoing call to GW $si ($ci)\n");
        route(DIALOGS_GET_INFO);
        route(DIALOGS_COPY_INFO);
    } else if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "200 OK from AS, incoming call from GW to AS $si ($ci)\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "Who the hell has started a new dialog!!?? IP address $si ($ci)\n");
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(log)) xlog("L_INFO", "Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::*");
}

event_route[dispatcher:dst-down] {
    if ($dlg_var(log)) xlog("L_ERR", "Destination down: $rm $ru ($du)\n");
}

event_route[dispatcher:dst-up] {
    if ($dlg_var(log)) xlog("L_ERR", "Destination up: $rm $ru\n");
}

onsend_route {
    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "Sent reply:\n\n$snd(buf)\n");
    }

    if(isflagset(FLT_REINVITE)) {
        if ($dlg_var(log)) xlog("L_INFO", "FLT_REINVITE is set, wait for 1 sec\n");
        sleep("1");
    }
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");

    # Ejemplo de lo que recibo de RTPengine:
    #    POST /RPC2 HTTP/1.1.
    #    Host: 5.196.32.135:5060.
    #    Accept: */*.
    #    Content-Type: text/xml.
    #    User-Agent: Xmlrpc-c/1.33.14 Curl/7.38.0.
    #    Content-Length: 210.
    #    
    #    <?xml version="1.0" encoding="UTF-8"?>
    #    <methodCall>
    #    <methodName>teardown</methodName>
    #    <params>
    #    <param><value><string>9c7bc06a-5d29-4bf0-8b89-faafd3da4f50</string></value></param>
    #    </params>
    #    </methodCall>

    # Ñapa del siglo para extraer de ese POST algo XML-alike para luego parsearlo con xmlops
    $var(x) = $(mb{s.select,-1,?}); # Busco la ultima '?' y me quedo de ahi en adelante
    $xml(x=>doc) = $(var(x){s.substr,1,0}); # Me quito '>\n' del principio y lo que queda es XML-alike

    # Extraigo methodName
    $var(methodName) = $xml(x=>xpath:/methodCall/methodName/text());
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: methodName: $var(methodName)\n");

    # Llamo a la ruta adecuada en funcion del comando
    if ($var(methodName) == "teardown")
        route(RTPTIMEOUT);
    else
        route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[RTPTIMEOUT] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "RTPTIMEOUT: RTPengine wants to hangup a call\n");
    $var(callid) = $xml(x=>xpath:/methodCall/params/param/value/string/text());
    $var(fromtag) = $sht(dialogs=>$var(callid)::from_tag);

    # Logica que obtiene $var(h_entry) y $var(h_id) partiendo de $var(callid) y del from_tag guardado en htable(dialogs)
    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.dlg_list" , "params" : [ "$var(callid)" , "$var(fromtag)" ], "id" : 1}');
    $var(json) = $jsonrpl(body);

    # Extraemos json del resultado
    json_get_field("$var(json)", "result", "$var(result)");
    json_get_field("$var(result)", "h_entry", "$var(h_entry)");

    # Extraemos h_entry y h_id
    json_get_field("$var(result)", "h_id", "$var(h_id)");

    # Matamos dialogo con ese h_entry y ese h_id
    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.end_dlg" , "params" : [ $var(h_entry) , $var(h_id) ], "id" : 2 }');

    if ($sel(cfg_get.dolog.xmlrpc)) {
        if ($jsonrpl(code) == "200") {
            xlog("L_INFO", "RTPTIMEOUT: Dialog ended: $jsonrpl(code) $jsonrpl(text)\n");
        } else {
            xlog("L_ERR", "RTPTIMEOUT: Problems killing dialog: $jsonrpl(code) $jsonrpl(text)\n");
        }
    }

    xmlrpc_reply("200", "Thanks for all the fish");
}

route[TRANSFORMATE_CALLEE_IN] {
    if ($avp(callee_in) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLEE_IN: No transformation needed in callee: $rU\n");
        return;
    }

    if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLEE_IN: Callee before: $rU\n");
    dp_translate("$avp(callee_in)");
    if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLEE_IN: Callee after: $rU (applied rule: $avp(appliedrule))\n");
    $avp(appliedrule) = $null;
}

route[TRANSFORMATE_CALLER_IN] {
    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_IN: PAI present: $(ai{uri.user})\n");
        $var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_IN: RPID present: $(re{uri.user})\n");
        $var(caller) = $(re{uri.user});
    } else {
        if ($dlg_var(log)) xlog("L_WARN", "TRANSFORMATE-CALLER_IN: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(caller) = $fU;
    }

    # Apply necessary transformations
    if ($avp(caller_in) != $null) dp_translate("$avp(caller_in)", "$var(caller)/$var(transformed_caller)");
    if ($avp(appliedrule) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_IN: No rule applied, caller is still $var(caller)\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_IN: Changed caller to $var(transformed_caller) (applied rule: $avp(appliedrule))\n");
        $var(caller) = $var(transformed_caller);
    }
    $avp(appliedrule) = $null;

    # If 00 + company_cc, remove
    if (pcre_match("$var(caller)", "^00$dlg_var(company_cc)")) {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_IN: Local caller to company, remove 00 + $dlg_var(company_cc) and proceed\n");
        $var(caller) = $(var(caller){s.strip,2}); # Remove 00
        $var(caller) = $(var(caller){s.strip,$(dlg_var(company_cc){s.len})}); # Remove company_cc
    }

    if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_IN: Final caller -> $var(caller)\n");

    # Set final caller in corresponding header
    if (is_present_hf("P-Asserted-Identity")) {
        remove_hf("Remote-Party-ID"); # If PAI present, RPID out
        remove_hf("P-Asserted-Identity");
        append_hf("P-Asserted-Identity: <sip:$var(caller)@$(ai{uri.host})>\r\n");
    } else if (is_present_hf("Remote-Party-ID")) {
        remove_hf("Remote-Party-ID");
        append_hf("Remote-Party-ID: <sip:$var(caller)@$(re{uri.host})>\r\n");
    } else {
        $fU = $var(caller);
    }
}

route[CONTROL_EXTERNAL_MAXCALLS] {
    if (get_profile_size("externalMaxCalls","$dlg_var(companyId)","$avp(externalCalls)"))
        if ($dlg_var(log)) xlog("L_INFO", "CONTROL-EXTERNAL-MAXCALLS: Currently, the company $dlg_var(companyName) (companyId: $dlg_var(companyId)) has $avp(externalCalls) active external calls\n");

    if ($avp(externalMaxCalls) == 0) {
        if ($dlg_var(log)) xlog("L_INFO", "CONTROL-EXTERNAL-MAXCALLS: Maxcalls not active for company $dlg_var(companyName) (companyId: $dlg_var(companyId)), count anyway\n");
        set_dlg_profile("externalMaxCalls","$dlg_var(companyId)");
        return;
    }

    if ($avp(externalCalls) < $avp(externalMaxCalls)) {
        if ($dlg_var(log)) xlog("L_INFO", "CONTROL-EXTERNAL-MAXCALLS: Call allowed, increment external-call counter to company $dlg_var(companyName) (companyId: $dlg_var(companyId))\n");
        set_dlg_profile("externalMaxCalls","$dlg_var(companyId)");
    } else {
        if ($dlg_var(log)) xlog("L_WARN", "CONTROL-EXTERNAL-MAXCALLS: Call NOT allowed, 403 Forbidden\n");
        sl_send_reply("403","Maxcalls exceeded");
        exit;
    }
}


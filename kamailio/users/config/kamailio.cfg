#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define XMLRPC_PORT 8000
#!define WEBSOCKETS_PORT 10080

#
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# FTL_NATS: Marca toda la transaccion como "tras NAT". Se comprueba al entrar una request.
# Se marca en 2 casos con la ayuda de la funcion nat_uac_test(19):
# 1. El contact tiene una IP privada
# 2. received_ip o received_port diferentes de los del Via
#
#!define FLT_NATS 5

# FLB_NATB: Marca el branch como "tras NAT".
# Se marca en 3 casos:
# 1. INVITE initial requests con uri!=myself (INVITE desde ASes) ---> Para tocar el contact?
# 2. En REGISTER tras NAT (hace que el registro guarde received)
# 3. Within-dialog requests con nat=yes en Route (a√±adido por nosotros en el INVITE que inicia este dialog si tras NAT) 
#
#!define FLB_NATB 6

# FLB_NATSIPPING: Habilita el SIP ping via OPTIONS de terminales que se registran tras NAT (ver caso 2 FLB_NATB)
#!define FLB_NATSIPPING 7

# DLG_FLAG
#!define DLG_FLAG 8

# ACC Flags
#!define FLT_ACC 9
#!define FLT_ACCMISSED 10

# RELATED Flag (when set, aleg found for this call in this proxy)
#!define FLT_ISBLEG 11

#!define FLT_ACCFAILED 12

# - options
###!define WITH_ANTIFLOOD

#!define WITH_MEDIALIBERATION
# Note: If defined, enable hack that avoids forwarding media liberation reINVITEs to endpoints

###!define WITH_RTPENGINE
# Note: RTPENGINE disables RTPPROXY and enables WS support (experimental mode)

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

#!define REGISTER_TIMEOUT 300

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 0 desc "If 1, log invite transactions"
dolog.register  = 0 desc "If 1, log register transactions"
dolog.publish   = 0 desc "If 1, log publish transactions"
dolog.subscribe = 0 desc "If 1, log subscribe transactions"
dolog.notify    = 0 desc "If 1, log notify transactions"
dolog.options   = 0 desc "If 1, log options transactions"
dolog.message   = 0 desc "If 1, log message transactions"
dolog.refer     = 0 desc "If 1, log refer transactions"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Global Parameters #########

listen=udp:IP:5060
listen=tcp:IP:5060
listen=tcp:IP:5061
listen=tcp:IP:XMLRPC_PORT

#!ifdef WITH_RTPENGINE
listen=tcp:IP:WEBSOCKETS_PORT
dolog.websocket = 0 desc "If 1, debug WS connection upgrade"
tcp_accept_no_cl=yes # Needed for WS
#!endif

# -- Debug level
debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "usrloc.so"
loadmodule    "registrar.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "nathelper.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "permissions.so"
loadmodule    "sqlops.so"
loadmodule    "cfg_rpc.so"
loadmodule    "acc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "auth.so"
loadmodule    "auth_db.so"
loadmodule    "domain.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "corex.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

#!ifdef WITH_RTPENGINE
loadmodule    "rtpengine.so"
loadmodule    "websocket.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpc-s.so"
loadmodule    "json.so"
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:22223")
#!else
loadmodule    "rtpproxy.so"
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")
#!endif

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_SOCK)")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@users.ivozprovider.local")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxyusers_ctl")

# TLS
modparam("tls", "config", "/etc/kamailio/proxyusers/tls.cfg")

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxyusers_fifo")

# USRLOC
modparam("usrloc", "use_domain", 0) # All domains are equal for me (as long as myself). Do not use domain in lookups
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "xavp_contact", "ulattrs")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# El parametro clave es debug (por defecto a 2 en este cfg)
# Se imprime todo lo que tenga <= que este valor (valores posibles: 0 - infinito)
# 0: De WARN (incluido) para arriba
# 1: De NOTICE (incluido) para arriba
# 2: De INFO (incluido) para arriba
# 3: De DBG (incluido) para arriba
# 
# Se puede modificar on-the-fly con:
# kamcmd cfg.seti core debug X
# Y obtener el valor actual con:
# kamcmd cfg.get core debug

# NAT
modparam("nathelper", "natping_interval", 60)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")

# REGISTER
modparam("registrar", "max_expires", REGISTER_TIMEOUT)
modparam("registrar", "max_contacts", 5)

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_users_address") # Allowed networks per company
modparam("permissions", "trusted_table", "kam_users_trusted") # Not used yet
modparam("permissions", "db_mode", 1)
modparam("permissions", "grp_col", "companyId")

# ACC
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 2)
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1)
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 0) 
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "acc_time_column", "localtime")

# -- to syslog
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- to database
modparam("acc", "db_table_acc", "kam_users_acc")
modparam("acc", "db_table_missed_calls", "kam_users_missed_calls")
modparam("acc", "cdrs_table", "kam_users_acc_cdrs")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd; cseq=$cs")
#modparam("acc", "multi_leg_info",
#    "leg_src=$avp(src);leg_dst=$avp(dst)")

# -- cdr accounting
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "companyId=$dlg_var(companyId);companyName=$dlg_var(companyName);caller=$dlg_var(caller);callee=$dlg_var(callee);type=$dlg_var(type);callid=$dlg_var(callid);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);subtype=$dlg_var(subtype)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCalls; internalCalls; inboundExtCalls; outboundExtCalls")
# Destruye dialogo si no hay BYE (se reinicia a cada request)
#modparam("dialog", "default_timeout", 21600)
#modparam("dialog", "default_timeout", 90)
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
# Las incluye en mensajes creados por el modulo dialog (BYEs)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n")
# Keep-alive (in-dialog OPTIONs)
#modparam("dialog", "ka_timer", 10)
#modparam("dialog", "ka_interval", 300)
# Interesante para: uac_auth()
modparam("dialog", "track_cseq_updates", 1)

# TM
modparam("tm", "fr_timer", 5000)
# enable serial/parallel forking
modparam("tm", "contacts_avp", "tm_contacts")
modparam("tm", "contact_flows_avp", "tm_contact_flows")
modparam("tm", "local_cancel_reason", 200)

# AUTH_DB
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "use_domain", 0)
#modparam("auth_db", "load_credentials", "") # Interesante para cargar AVP per subscriber

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;dbtable=kam_users_htable")
#!endif

modparam("htable", "htable", "dialogs=>size=10;autoexpire=0;dbtable=kam_users_htable")

# SANITY
modparam("sanity", "autodrop", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_users_domain")
modparam("domain", "domain_attrs_table", "kam_users_domain_attrs")
modparam("domain", "register_myself", 1)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

####### Routing Logic ########

request_route {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "Request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        if ($dlg_var(log)) xlog("L_NOTICE","Send 200 to '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");
        send_reply("200", "I'm here!");
        exit;
    }

    # per request initial checks
    route(REQINIT);

    # Setup accounting
    route(ACCOUNTING);

#!ifdef WITH_RTPENGINE
    # NAT/WS detection
    if (nat_uac_test(64)) # 64 - Test if the source connection of signaling is WS
        route(WSDETECT);
    else
        route(NATDETECT);
#!else
    route(NATDETECT);
#!endif

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "----> $rm from $si\n");

        if (t_check_trans())
            route(RELAY);

        exit;
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "In dialog request - has_to_tag\n");
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    if ($dlg_var(log)) xlog("L_INFO", "NOT in dialog request - not has_to_tag: Initial transaction\n");

    # Manage retransmissions
    t_check_trans();

    # Discard unsupported methods
    if (!is_method("INVITE|REGISTER|SUBSCRIBE|NOTIFY|PUBLISH")) {
        if ($dlg_var(log)) xlog("L_WARN", "$rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Manage authentication
    route(AUTH);

    # Remove preloaded route headers
    if ($dlg_var(log)) xlog("L_INFO", "Remove preloaded route headers\n");
    remove_hf("Route");

    # Handle everything except INVITEs
    if(is_method("REGISTER")) {
        route(REGISTER);
    } else if(is_method("SUBSCRIBE")) {
        route(SUBSCRIBE);
    } else if(is_method("NOTIFY")) {
        route(NOTIFY);
    } else if(is_method("PUBLISH")) {
        route(PUBLISH);
    }

    # From now on, everything is for INVITEs: track dialog
    if ($dlg_var(log)) xlog("L_INFO", "dialog_manage()\n");
    dlg_manage();
    #dlg_set_property("ka-src");
    #dlg_set_property("ka-dst");

    # Add record-route to INVITE requests
    if ($dlg_var(log)) xlog("L_INFO", "Add record-route\n");
    record_route();

    # uri!=myself:
    # (a) from_uri==myself: Local subscriber calling to external domain
    # (b) from_uri!=myself: Trusted host with incorrect domain in R-URI
    if (uri!=myself) {
        if ($dlg_var(log)) xlog("L_INFO", "R-URI not for my domain\n");
        if (from_uri==myself) {
            # (a) Local subscriber calling to external domain
            if ($dlg_var(log)) xlog("L_ERR", "Local subscriber calling to external domain, 501 Not implemented\n");
            send_reply("501", "Not Implemented");
            exit;
        } else {
            # (b) Trusted host with incorrect domain in R-URI
            # Solo puede llegar aqui alguien que haya superado ds_is_from_list("1") en AUTH,
            # porque si no se habria descartado por open relay

            # Desde el cambio de ser location server, AS no deberia escribir sin mi dominio en el R-URI
            xlog("L_ERR", "AS talking with incorrect domain in R-URI ($ru), check!!\n");
            send_reply("500", "Invalid URI domain");
            exit;
        }
    }

    # uri==myself
    # (a) from_uri==myself: Local subscriber calling to my domain
    # (b) from_uri!=myself:
    #   (b1) AS
    #   (b2) DROP
    if ($dlg_var(log)) xlog("L_INFO", "R-URI: My domain\n");

    if (from_uri==myself) {
        # (a) from_uri==myself: Local subscriber calling to my domain
        if ($dlg_var(log)) xlog("L_INFO", "Local subscriber calling to my domain, dispatch to AS(-es)\n");
        route(DIALOGS_GET_INFO);
        route(GET_INFO_FROM_TERMINAL);
        route(FILTER_BY_SCR_ADDR);
        if ($rU =~ '^\*') {
            if ($dlg_var(log)) xlog("L_INFO", "Calling to feature-like $rU, ringall all AS-es\n");
            $dlg_var(type) = "saliente";
            $dlg_var(subtype) = "interna";
            route(RINGALL_AS);
            route(RELAY);
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "Calling to non-feature-like $rU, dispatch to any AS\n");
            route(PROFILE_UAC_CALL);
            route(OUTBOUND_PREFIX);
            route(DISPATCH);
            route(RELAY);
        }
    } else {
        if (ds_is_from_list("1")) {
            # (b1) AS calling to local subscriber
            if ($dlg_var(log)) xlog("L_INFO", "AS calling to local subscriber, relay to subcriber\n");
            route(PARSE_X_HEADERS);
            route(RELATE_LEGS);
            route(LOOKUP);
            route(PROFILE_AS_CALL);
            route(TRANSFORMATE_CALLER_OUT);
            route(RELAY);
        } else {
            # (b2) from_uri!=myself: Who is calling?? ProxyUsers only receives from subscribers and AS-es -> Drop
            if ($dlg_var(log)) xlog("L_ERR", "Who is calling?? ProxyUsers only receives from subscribers and AS-es -> Drop\n");
            send_reply("403", "Forbidden");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR","Main script error, should NOT arrive this point.\n");
    drop;
}

route[DISPATCH] {
    # round robin dispatching on ASs
    if(!ds_select_dst("1", "4")) {
        if ($dlg_var(log)) xlog("L_ERR", "DISPATCH: No destination found\n");
        send_reply("404", "No destination");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "DISPATCH: going to <$ru> via <$du>\n");
    t_on_failure("MANAGE_FAILURE_AS_DISPATCH");
}

route[LOOKUP] {
    if ($dlg_var(log)) xlog("L_INFO", "LOOKUP: Look up $ru on location DB\n");
    lookup("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_ERR", "LOOKUP: Contact not not found for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
        case -2:
            if ($dlg_var(log)) xlog("L_ERR", "LOOKUP: Contacts found, but method not supported for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
        case -3:
            if ($dlg_var(log)) xlog("L_ERR", "LOOKUP: Internal error during processing lookup for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
    };

    # Handle multiple contacts
    if (!t_load_contacts()) {
        if ($dlg_var(log)) xlog("L_ERR", "LOOKUP: Error loading contacts for $rU\n");
        sl_send_reply("500", "Server Internal Error - Cannot load contacts");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "LOOKUP: Contacts loaded for $rU\n");
    }

    # Load contact or contacts
    if (!t_next_contacts()) {
        if ($dlg_var(log)) xlog("L_INFO", "LOOKUP: t_next_contacts - Only one contact found for $rU, calling\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "LOOKUP: t_next_contacts - Multiple contacts found for $rU, parallel forking\n");
    }

    # Add failure route
    t_on_failure("MANAGE_FAILURE_UAC");
}

route[GET_INFO_FROM_TERMINAL] {
    # Del nombre del terminal origen, saco todo lo necesario
    sql_xquery("cb", "SELECT EXT.number AS userExtension, C.id AS companyId, C.name AS companyName, C.outbound_prefix AS outboundPrefix, C.mediaRelaySetsId, CS.calling_code AS company_cc, CSS.calling_code AS user_cc FROM Terminals T LEFT JOIN Users U ON U.terminalId=T.id LEFT JOIN Extensions EXT ON EXT.Id=U.extensionId LEFT JOIN Companies C ON T.companyId=C.id LEFT JOIN Countries CS ON CS.Id=C.countryId LEFT JOIN Countries CSS ON CSS.Id=U.countryId WHERE T.name='$fU'", "ra");
    
    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: caller: $xavp(ra=>userExtension)\n");
    $dlg_var(caller) = $xavp(ra=>userExtension);

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: companyId: $xavp(ra=>companyId)\n");
    $dlg_var(companyId) = $xavp(ra=>companyId);
    if ($dlg_var(companyId) == $null) {
        if ($dlg_var(log)) xlog("L_ERR", "GET-INFO-FROM-TERMINAL: companyId not found, 500 Server Internal Error\n");
        sl_send_reply("500", "Server Internal Error");
        exit;
    }

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: companyName: $xavp(ra=>companyName)\n");
    $dlg_var(companyName) = $xavp(ra=>companyName);

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: outboundPrefix: $xavp(ra=>outboundPrefix)\n");
    $dlg_var(outboundPrefix) = $xavp(ra=>outboundPrefix);

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: company_cc: $xavp(ra=>company_cc)\n");
    $dlg_var(company_cc) = $xavp(ra=>company_cc);
    if ($dlg_var(company_cc) == $null) {
        if ($dlg_var(log)) xlog("L_WARN", "GET-INFO-FROM-TERMINAL: company_cc not set, set to default calling code (spain, 34)\n");
        $dlg_var(company_cc) = 34;
    }

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: user_cc: $xavp(ra=>user_cc)\n");
    $dlg_var(user_cc) = $xavp(ra=>user_cc);
    if ($dlg_var(user_cc) == $null) {
        if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: user_cc not set, set to company_cc value\n");
        $dlg_var(user_cc) = $xavp(ra=>company_cc);
    }

    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: mediaRelaySetsId: $xavp(ra=>mediaRelaySetsId)\n");
    $var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);
    if ($(var(mediaRelaySetsId){s.len}) > 0 && $var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_WARN", "GET-INFO-FROM-TERMINAL: Custom rtpproxy set: $var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(var(mediaRelaySetsId){s.int})");
    }
}

route[FILTER_BY_SCR_ADDR] {
    if ($dlg_var(log)) xlog("L_INFO", "GET-INFO-FROM-TERMINAL: caller: $xavp(ra=>userExtension)\n");
    if (!allow_source_address($dlg_var(companyId))) {
        if ($dlg_var(log)) xlog("L_WARN", "FILTER_BY_SCR_ADDR: $si is not valid for company $dlg_var(companyName) (id: $dlg_var(companyId))\n");
        sl_send_reply("403", "Forbidden");
        exit;
    }
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);

    # Extract brandId
    $var(header) = 'X-Info-Callee';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(callee) = $var(header-value);

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    $var(mediaRelaySetsId) = $var(header-value);

    if ($(var(mediaRelaySetsId){s.len}) > 0 && $var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_WARN", "PARSE-X-HEADERS: Custom rtpproxy set: $var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(var(mediaRelaySetsId){s.int})");
    }

    # Extract outboundPrefix (can be null)
    $var(header) = 'X-Info-OutPrefix';
    if (is_present_hf($var(header))) {
        $dlg_var(outboundPrefix) = $hdr($var(header));
        remove_hf($var(header));
        if ($dlg_var(log)) xlog("L_INFO", "PARSE-X-HEADER: outboundPrefix: $dlg_var(outboundPrefix)\n");
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "PARSE-X-HEADER: $var(header) not present or not valid, aborting\n");
        sl_send_reply("500", "Missing $var(header)");
        exit;
    }
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        if ($(hdr($var(header)){s.len})) {
            if ($dlg_var(log)) xlog("L_INFO", "PARSE-OPTIONAL-X-HEADER: $var(header): $hdr($var(header))\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "PARSE-OPTIONAL-X-HEADER: $var(header): <empty>\n");
        }
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "PARSE-OPTIONAL-X-HEADER: $var(header) not present\n");
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "PARSE-MANDATORY-X-HEADER: $var(header): $hdr($var(header))\n");
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        sl_send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[PROFILE_UAC_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "PROFILE-UAC-CALL: Type-> saliente\n");
    $dlg_var(type) = "saliente";
    
    # Interna / Externa
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS esInterna FROM Extensions E WHERE number='$rU' AND companyId='$dlg_var(companyId)'", "ra");
    if ($xavp(ra=>esInterna) == '1' || pcre_match("$rU", "^\*")) {
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-UAC-CALL: Subtype-> interna\n");
        $dlg_var(subtype) = 'interna';
        # Internal calls will be profiled only in bleg (to avoid duplicates)
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-UAC-CALL: Subtype-> externa\n");
        $dlg_var(subtype) = 'externa';

        # Outbound external calls by company
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-UAC-CALL: Profile-> outboundExtCalls\n");
        $dlg_var(profile) = "Outbound external call";
        set_dlg_profile("outboundExtCalls", "$dlg_var(companyId)");

        # Active calls by company
        set_dlg_profile("activeCalls", "$dlg_var(companyId)");
    }
}

route[PRINT_STATS] {
    # Global stats
    if(get_profile_size("activeCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: Global stat: $avp(size) active calls\n");
    }

    if(get_profile_size("internalCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: Global stat: $avp(size) internal calls\n");
    }

    if(get_profile_size("outboundExtCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: Global stat: $avp(size) external outbound calls\n");
    }

    if(get_profile_size("inboundExtCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: Global stat: $avp(size) external inbound calls\n");
    }

    # Company stats
    if(get_profile_size("activeCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) active calls\n");
    }

    if(get_profile_size("internalCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) internal calls\n");
    }

    if(get_profile_size("outboundExtCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) external outbound calls\n");
    }

    if(get_profile_size("inboundExtCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) external inbound calls\n");
    }
}

route[PROFILE_AS_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "PROFILE-AS-CALL: Type-> entrante\n");
    $dlg_var(type) = "entrante";

    # Interna / Externa
    if (isflagset(FLT_ISBLEG)) {
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-AS-CALL: Subtype-> interna\n");
        $dlg_var(subtype) = 'interna';

        # Internal calls by company
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-AS-CALL: Profile-> internalCalls\n");
        $dlg_var(profile) = "Internal call";
        set_dlg_profile("internalCalls", "$dlg_var(companyId)");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-AS-CALL: Subtype-> externa\n");
        $dlg_var(subtype) = 'externa';

        # Inbound external calls by company
        if ($dlg_var(log)) xlog("L_INFO", "PROFILE-AS-CALL: Profile-> inboundExtCalls\n");
        $dlg_var(profile) = "Inbound external call";
        set_dlg_profile("inboundExtCalls", "$dlg_var(companyId)");
    }

    # Active calls by company
    set_dlg_profile("activeCalls", "$dlg_var(companyId)");
}

# Authentication route
route[AUTH] {
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "AUTH: No auth for AS request\n");
        return;
    }

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "Terminals", "1")) {
            if ($dlg_var(log)) xlog("L_INFO", "AUTH: Auth needed\n");
            auth_challenge("$fd", "0");
            exit;
        }

        if ($dlg_var(log)) xlog("L_INFO", "AUTH: Authentication OK, consume credentials\n");
        # user authenticated - remove auth header
        consume_credentials();
    }

    # if caller is not local subscriber, then check if it calls
    # a local destination, otherwise deny, not an open relay here
    if (from_uri!=myself && uri!=myself) {
        if ($dlg_var(log)) xlog("L_ERR", "Not open relay here!\n");
        sl_send_reply("403","Not relaying");
        exit;
    }

    return;
}

route[MEDIALIBERATION] {
#!ifdef WITH_MEDIALIBERATION
    if (is_method("ACK") && $dlg_var(discardack) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "MEDIALIBERATION: Drop ACK, magic part 2 of 2!\n");
        $dlg_var(discardack) = $null;
        exit;
    }

    if (is_method("INVITE|UPDATE") && has_body("application/sdp") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "MEDIALIBERATION: Re-$rm from AS, evaluate doing magic\n");
        if (!sdp_get_line_startswith("$avp(cline)", "c=IN IP4 " + $si)) {
            if ($dlg_var(log)) xlog("L_INFO", "MEDIALIBERATION: RTPproxy on SDP, start magic!\n");
            if ($dlg_var(log)) xlog("L_INFO", "MEDIALIBERATION: Mangle RTPproxy ports and reply 200, magic part 1 of 2!\n");
            if (is_method("INVITE"))
                $dlg_var(discardack) = '1'; # Set dlg_flag to discard subsequent ACK
            route(RTPRELAY); # Call RTPRELAY to link ports accordingly
            send_reply("200", "I agree");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "MEDIALIBERATION: SDP does not contain RTPproxy ($avp(cline)), abort magic\n");
        }
    }
#!endif
    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    # Do not forward media liberation reinvite
    route(MEDIALIBERATION);

    # Volvemos a modificar el CALLER en caso de UPDATEs y reINVITEs
    if (is_method("INVITE|UPDATE") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "WITHINDLG: In-dialog $rm request from AS, re-transformate caller\n");
        route(TRANSFORMATE_CALLER_OUT);
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RURIALIAS);
        if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        sl_send_reply("404","Not here");
    }
    exit;
}

# URI update for requests where alias found
route[RURIALIAS] {
    if(isdsturiset()) {
        if ($dlg_var(log)) xlog("L_INFO", "RURIALIAS: Destination URI is set, no un-aliasing is needed\n");
        return;
    }

    if ($dlg_var(log)) xlog("L_INFO", "RURIALIAS: Route using R-URI, any alias on R-URI?\n");

    handle_ruri_alias();
    switch ($rc) {
    case -1:
        if ($dlg_var(log)) xlog("L_ERR", "RURIALIAS: Failed to handle alias of R-URI $ru\n");
        send_reply("400", "Bad request");
        exit;
    case 1:
        if ($dlg_var(log)) xlog("L_INFO", "RURIALIAS: Alias parsed, routing $rm from $fu to $du\n");
        break;
    case 2:
        if ($dlg_var(log)) xlog("L_INFO", "RURIALIAS: Alias not found, routing $rm from $fu to $ru\n");
        break;
    };

    return;
}

# Relay request
route[RELAY] {
    if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

# Initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    # flood dection from same IP and traffic ban for a while
    # be sure you exclude checking trusted peers, such as pstn gateways
    # - local host excluded (e.g., loop to self)
    if(src_ip!=myself && !ds_is_from_list("1")) {
        if($sht(ipban=>$si)!=$null) {
            # ip is already blocked
            if ($dlg_var(log)) xlog("L_ERR", "REQINIT: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            if ($dlg_var(log)) xlog("L_ERR", "REQINIT: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
    }
#!endif

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        if ($dlg_var(log)) xlog("L_ERR", "REQINIT: Too many hops for SIP message from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        if ($dlg_var(log)) xlog("L_ERR", "REQINIT: Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Easy dropping for sipvicious scans
    if (search("sipvicious")) {
        if ($dlg_var(log)) xlog("L_WARN", "REQINIT: DROPPED SIPVICIOUS ----> $rm from $si\n");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "REQINIT: All checks passed, continue...\n");
}

# Handle SIP registrations
route[REGISTER] {
    if(isflagset(FLT_NATS)) {
        if ($dlg_var(log)) xlog("L_INFO", "REGISTER: NAT must be kept open\n");
        setbflag(FLB_NATB);
        # Enable SIP NAT pinging 
        if ($proto == 'udp') {
            if ($dlg_var(log)) xlog("L_INFO", "REGISTER: Enable UDP SIP OPTIONS PINGING\n");
            setbflag(FLB_NATSIPPING);
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "REGISTER: Enable TCP raw NAT keeper\n");
        }
    }

    # Store in kam_users_location_attrs used transport to retrieve it in lookup
    $xavp(ulattrs=>transport) = $proto;

    $var(contact_uri) = @contact.uri;
    save("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_WARN", "REGISTER: Something went wrong when saving location\n");
            sl_reply_error();
            break;
        case 1:
            if ($dlg_var(log)) xlog("L_INFO", "REGISTER: Contacts inserted ($tu: $var(contact_uri))\n");
            break;
        case 2:
            if ($dlg_var(log)) xlog("L_INFO", "REGISTER: Contacts updated ($tu: $var(contact_uri))\n");
            break;
        case 3:
            if ($dlg_var(log)) xlog("L_INFO", "REGISTER: Contacts deleted ($tu: $var(contact_uri))\n");
            break;
        case 4:
            if ($dlg_var(log)) xlog("L_INFO", "REGISTER: Contacts returned\n");
            break;
    };
 
    exit;
}

# Handle SUBSCRIBE messages
route[SUBSCRIBE] {
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARNING", "SUBSCRIBE: Received $rm from AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Add record-route to SUBSCRIBE requests
    if ($dlg_var(log)) xlog("L_INFO", "SUBSCRIBE: Add record-route\n");
    record_route();

    # Dispatch SUBSCRIBE to any AS
    route(DISPATCH);
    route(RELAY);
}

# Handle NOTIFY messages
route[NOTIFY] {
    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARNING", "NOTIFY: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Lookup contact and relay
    route(LOOKUP);
    route(RELAY);
}

# Handle PUBLISH messages
route[PUBLISH] {
    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARNING", "PUBLISH: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Republish to remaining AS-es
    route(REPUBLISH);
}

route[RINGALL_AS] {
    if ($dlg_var(log)) xlog("L_INFO", "RINGALL-AS: Parallel forking to all available AS-es\n");

    # Load AS-es
    if(!ds_select_dst("1", "4")) {
        if ($dlg_var(log)) xlog("L_ERR", "RINGALL-AS: No AS found\n");
        exit;
    }

    # Main branch
    $var(finaldu) = $du;
    if ($dlg_var(log)) xlog("L_INFO", "RINGALL-AS: Ringall[0]: $var(finaldu)\n");

    # Extra branches
    $var(i)¬†=¬†1; # idx 0 is set as finaldu
    while(is_avp_set("$(avp(AVP_DST)[$var(i)])"))¬†{
        $du = $(avp(AVP_DST)[$var(i)]);
        append_branch();

        if ($dlg_var(log)) xlog("L_INFO", "RINGALL-AS: Ringall[$var(i)]: $(avp(AVP_DST)[$var(i)])\n");

    ¬†¬†¬†¬†$var(i)¬†=¬†$var(i)¬†+¬†1;
    }

    # Re-set main branch
    $du = $var(finaldu);

    # Add failure route
    t_on_failure("MANAGE_FAILURE_AS_RINGALL");
}

route[REPUBLISH] {
    if ($dlg_var(log)) xlog("L_INFO", "REPUBLISH: Send PUBLISH from $si to remaining AS-es\n");

    sl_send_reply("200", "OK, republishing");
    t_release();

    if(!ds_select_dst("1", "4")) {
        if ($dlg_var(log)) xlog("L_ERR", "REPUBLISH: No destination found\n");
        exit;
    }

    $var(i)¬†=¬†0;
    while(is_avp_set("$(avp(AVP_DST)[$var(i)])"))¬†{
        $du = $(avp(AVP_DST)[$var(i)]);
        if ($dlg_var(log)) xlog("L_INFO", "REPUBLISH: Forward[$var(i)]: $du\n");
        route(AVOID_SRC);

        $var(i)¬†=¬†$var(i)¬†+¬†1;
    }

    exit;
}

route[AVOID_SRC] {
    if ($(du{s.select,1,:}) == $si) {
        if ($dlg_var(log)) xlog("L_INFO", "REPUBLISH: not sending to original source, skip\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "REPUBLISH: destination found, going to <$ru> via <$du>\n");
        forward();
    }
}

# Detect NAT
route[NATDETECT] {
    if ($dlg_var(log)) xlog("L_INFO", "NATDETECT: Force rport\n");
    force_rport();

    # 19: 1 + 2 + 16
    # 1 - The "Contact" header field is searched for occurrence of RFC1918 or RFC6598 addresses.
    # 2 - the "received" test is used: address in the "Via" header is compared against source IP address of signaling
    # 16 - Test if the source port is different from the port in the "Via" header
    if (nat_uac_test("19")) {
        if ($dlg_var(log)) xlog("L_INFO", "NATDETECT: NAT detected, set FLT_NATS\n");
        setflag(FLT_NATS);

        if (is_method("REGISTER")) {
            if ($dlg_var(log)) xlog("L_INFO", "NATDETECT: REGISTER ---> fix_nated_register\n");
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                if ($dlg_var(log)) xlog("L_INFO", "NATDETECT: Non-REGISTER and first hop ---> Add contact alias\n");
                # Sets ;alias only if received ip and port differ from those in contact URI
                if (!add_contact_alias()) {
                   if ($dlg_var(log)) xlog("L_ERR", "NATDETECT: Error in aliasing contact $ct\n");
                   send_reply("400", "Bad request");
                   exit;
                }
            }
        }
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "NATDETECT: No NAT detected\n");
    }
}

#!ifdef WITH_RTPENGINE
route[WSDETECT] {
    if ($dlg_var(log)) xlog("L_INFO", "WSDETECT: Websockets detected, fix contact\n");
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    force_rport();
    if (is_method("REGISTER")) {
        if ($dlg_var(log)) xlog("L_INFO", "WSDETECT: Add Received AVP to be stored by userloc with $proto:$si:$sp\n");
        fix_nated_register();
    } else if (!add_contact_alias()) {
        if($dlg_var(nolog) != "1") xlog("L_ERR", "Error aliasing contact <$ct>\n");
        sl_send_reply("400", "Bad Request");
        exit;
    }
    return;
}
#!endif

# Handle NAT
route[NATMANAGE] {
    # RTP handling is always enforced
    if ($dlg_var(log)) xlog("L_INFO", "NATMANAGE: Force RTPRELAY\n");
    route(RTPRELAY);

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header
    if (is_request() && has_totag() && check_route_param("nat=yes")) {
       if ($dlg_var(log)) xlog("L_INFO", "NATMANAGE: Set FLB_NATB (reason: within-dialog request with nat=yes on Route header)\n");
       setbflag(FLB_NATB); 
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        if ($dlg_var(log)) xlog("L_INFO", "NATMANAGE: No endpoint is behind NAT, return\n");
        return;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "NATMANAGE: One or both endpoints are behind NAT, continue!\n");
    }

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        if ($dlg_var(log)) xlog("L_INFO", "NATMANAGE: Add nat=yes to record-route (reason: initial request called from branch route)\n");
        add_rr_param(";nat=yes");
    }
    
    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        if ($dlg_var(log)) xlog("L_INFO", "NATMANAGE: Add contact alias (reason: reply with NATB set and first hop)\n");
        # Sets ;alias only if received ip and port differ from those in contact URI
        if (!add_contact_alias()) {
           if ($dlg_var(log)) xlog("L_ERR", "NATMANAGE: Error in aliasing contact $ct\n");
           send_reply("400", "Bad request");
           exit;
        }
    }
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    return;
}

route[RELATE_LEGS] {
    if ($sht(dialogs=>$dlg_var(xcallid)::source_ip) != '') {
        if ($dlg_var(log)) xlog("L_INFO", "RELATE-LEGS: $ci aleg is $dlg_var(xcallid), set FLT-ISBLEG\n");
        setflag(FLT_ISBLEG);
        $sht(dialogs=>$ci::aleg) = $dlg_var(xcallid);

        if ($dlg_var(log)) xlog("L_INFO", "RELATE-LEGS: $dlg_var(xcallid) bleg is $ci\n");
        $sht(dialogs=>$dlg_var(xcallid)::bleg) = $ci;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "RELATE-LEGS: $dlg_var(xcallid) not present in dialogs htable, skip\n");
    }
}

route[DIALOGS_GET_INFO] {
    if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Set source_ip to $si\n");
    $sht(dialogs=>$ci::source_ip) = $si;

    if (sdp_content()) {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Has SDP, check por m= and c= lines\n");
    
        if(sdp_get_line_startswith("$avp(cline)", "c=")) {
            if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Set media_ip to $(avp(cline){s.select,2, })\n");
            $sht(dialogs=>$ci::media_ip) = $(avp(cline){s.select,2, });
        }
    
        if (sdp_get_line_startswith("$avp(mline)", "m=")) {
            if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-GET-INFO: Set media_port to $(avp(mline){s.select,1, })\n");
            $sht(dialogs=>$ci::media_port) = $(avp(mline){s.select,1, });
        }
    }
}

route[DIALOGS_COPY_INFO] {
    # If aleg found for this dialog, copy keys from each one to another
    if (isflagset(FLT_ISBLEG)) {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: aleg found for $ci, copy remote keys and vice versa\n");
        $avp(aleg) = $sht(dialogs=>$ci::aleg);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: aleg not found for $ci, return\n");
        return;
    }

    # Copy leg1 ($avp(aleg)) info to leg2 ($ci) with remote prefix
    $sht(dialogs=>$ci::remote_source_ip) = $sht(dialogs=>$avp(aleg)::source_ip);
    $sht(dialogs=>$ci::remote_media_ip) = $sht(dialogs=>$avp(aleg)::media_ip);
    $sht(dialogs=>$ci::remote_media_port) = $sht(dialogs=>$avp(aleg)::media_port);

    # Copy leg2 ($ci) info to leg1 ($avp(aleg)) with remote prefix
    $sht(dialogs=>$avp(aleg)::remote_source_ip) = $sht(dialogs=>$ci::source_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_ip) = $sht(dialogs=>$ci::media_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_port) = $sht(dialogs=>$ci::media_port);

    # Try to guest if directmedia seems possible
    if ($sht(dialogs=>$ci::source_ip) == $sht(dialogs=>$ci::remote_source_ip)) {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: Source IP of both endpoints is equal, directmedia seems legit\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "DIALOGS-COPY-INFO: Source IP of both endpoints is NOT equal, directmedia NOT possible\n");
    }
}

route[ACCOUNTING] {
    if (!is_method("INVITE|BYE|CANCEL"))
        return;

    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED);

    if (is_method("INVITE")) {
        setflag(FLT_ACCMISSED);
        if (!has_totag()) {
            # Get info from initial request only
            $dlg_var(caller) = $fU;
            $dlg_var(callee) = $rU;
            $dlg_var(callid) = $ci;
            if (is_present_hf("Diversion"))
                $dlg_var(diversion) = $(di{uri.user});
        }
    }
}

# Reply generic route (all replies goes through this route)
onreply_route {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");

    if (is_method("PUBLISH") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "Drop '$rs $rr' from AS to PUBLISH\n");
        drop;
    }
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    if ($dlg_var(log)) xlog("L_INFO", "MANAGE_REPLY: Additional for all replies\n");

    # Manage NAT
    if ($rs =~ "[12][0-9][0-9]") {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_REPLY: Non-error reply $rs, call NATMANAGE\n");
        route(NATMANAGE);
    }
    
    # Manage WS
    if (nat_uac_test(64)) {
        if ($dlg_var(log)) xlog("L_INFO", "MANAGE_REPLY: add_contact_alias\n");
        # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        add_contact_alias();
    }
}

failure_route[MANAGE_FAILURE] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE: Call NATMANAGE\n");
    route(NATMANAGE);

    if ($dlg_var(log)) xlog("L_WARN","MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ($dlg_var(log)) xlog("L_ERR","MANAGE-FAILURE: This route should NOT be used, main logic error\n");
    exit;
}

failure_route[MANAGE_FAILURE_UAC] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE-UAC: Call NATMANAGE\n");
    route(NATMANAGE);

    if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-UAC: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-UAC: t_is_canceled, exit here\n");
        exit;
    }

    # Error calling to UAC, forward answer to AS
    if ($dlg_var(log)) xlog("L_WARN", "MANAGE-FAILURE-UAC: no failure logic for UAC calls, forward answer to AS\n");
    exit;
}

failure_route[MANAGE_FAILURE_AS_RINGALL] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE-AS-RINGALL: Call NATMANAGE\n");
    route(NATMANAGE);

    if ($dlg_var(log)) xlog("L_ERR","MANAGE-FAILURE-AS-RINGALL: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");
    t_on_failure("MANAGE_FAILURE_AS_RINGALL");
}

failure_route[MANAGE_FAILURE_AS_DISPATCH] {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE-AS-DISPATCH: Call NATMANAGE\n");
    route(NATMANAGE);

    if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-AS-DISPATCH: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-AS-DISPATCH: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 500 or local timeout
    if (t_check_status("500") or (t_branch_timeout() and !t_branch_replied())) {
        ds_mark_dst("ip");
        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS_DISPATCH");
            if ($dlg_var(log)) xlog("L_INFO", "MANAGE-FAILURE-AS-DISPATCH: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-AS-DISPATCH: No more AS-s available\n");
            exit;
        }
    }

    # AS responde algo inesperado, abortamos failover y enviamos 408 Timeout
    if ($dlg_var(log)) xlog("L_ERR", "MANAGE-FAILURE-AS-DISPATCH: Something went wrong, AS seems bugged!\n");
    exit;
}

# Route for branching: Only for INVITEs and BYEs (fork-able)
branch_route[MANAGE_BRANCH] {
    if ($dlg_var(log)) xlog("L_WARN", "MANAGE_BRANCH: NEW BRANCH [$T_branch_idx] to $du (R-URI: $ru)\n");

    # Manage NAT
    if ($dlg_var(log)) xlog("L_INFO", "MANAGE-BRANCH: Call NATMANAGE\n");
    route(NATMANAGE);
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if (!ds_is_from_list("1")) {
        # Call to DIALOGS_GET_INFO and DIALOGS_COPY_INFO only for 200 OK from UACs
        if ($dlg_var(log)) xlog("L_INFO", "Invoke DIALOGS_GET_INFO for 200 OK from UAC ($ci)\n");
        route(DIALOGS_GET_INFO);
        route(DIALOGS_COPY_INFO);
    }

    if ($dlg_var(profile) != $null) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: $dlg_var(profile) established for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
        route(PRINT_STATS);
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(log)) xlog("L_INFO", "Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::*");

    if ($dlg_var(profile) != $null) {
        if ($dlg_var(log)) xlog("L_INFO", "PRINT-STATS: $dlg_var(profile) ended for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
        route(PRINT_STATS);
    }
}

onsend_route {
    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "Sent request:\n\n$snd(buf)\n");
        else 
            xlog("L_WARN", "Sent reply:\n\n$snd(buf)\n");
    }
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");

    # Ejemplo de lo que recibo de RTPengine:
    #    POST /RPC2 HTTP/1.1.
    #    Host: 5.196.32.135:5060.
    #    Accept: */*.
    #    Content-Type: text/xml.
    #    User-Agent: Xmlrpc-c/1.33.14 Curl/7.38.0.
    #    Content-Length: 210.
    #    
    #    <?xml version="1.0" encoding="UTF-8"?>
    #    <methodCall>
    #    <methodName>teardown</methodName>
    #    <params>
    #    <param><value><string>9c7bc06a-5d29-4bf0-8b89-faafd3da4f50</string></value></param>
    #    </params>
    #    </methodCall>

    # √ëapa del siglo para extraer de ese POST algo XML-alike para luego parsearlo con xmlops
    $var(x) = $(mb{s.select,-1,?}); # Busco la ultima '?' y me quedo de ahi en adelante
    $xml(x=>doc) = $(var(x){s.substr,1,0}); # Me quito '>\n' del principio y lo que queda es XML-alike

    # Extraigo methodName
    $var(methodName) = $xml(x=>xpath:/methodCall/methodName/text());
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: methodName: $var(methodName)\n");

    # Llamo a la ruta adecuada en funcion del comando
    if ($var(methodName) == "teardown")
        route(RTPTIMEOUT);
    else
        route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[RTPTIMEOUT] {
#!ifdef WITH_RTPENGINE
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "RTPTIMEOUT: RTPengine wants to hangup a call\n");
    $var(callid) = $xml(x=>xpath:/methodCall/params/param/value/string/text());
    $var(fromtag) = $sht(dialogs=>$var(callid)::from_tag);

    # Logica que obtiene $var(h_entry) y $var(h_id) partiendo de $var(callid) y del from_tag guardado en htable(dialogs)
    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.dlg_list" , "params" : [ "$var(callid)" , "$var(fromtag)" ], "id" : 1}');
    $var(json) = $jsonrpl(body);

    # Extraemos json del resultado
    json_get_field("$var(json)", "result", "$var(result)");
    json_get_field("$var(result)", "h_entry", "$var(h_entry)");

    # Extraemos h_entry y h_id
    json_get_field("$var(result)", "h_id", "$var(h_id)");

    # Matamos dialogo con ese h_entry y ese h_id
    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.end_dlg" , "params" : [ $var(h_entry) , $var(h_id) ], "id" : 2 }');

    if ($sel(cfg_get.dolog.xmlrpc)) {
        if ($jsonrpl(code) == "200") {
            xlog("L_INFO", "RTPTIMEOUT: Dialog ended: $jsonrpl(code) $jsonrpl(text)\n");
        } else {
            xlog("L_ERR", "RTPTIMEOUT: Problems killing dialog: $jsonrpl(code) $jsonrpl(text)\n");
        }
    }

    xmlrpc_reply("200", "Thanks for all the fish");
#!endif
    return;
}

route[OUTBOUND_PREFIX] {
    if ($dlg_var(subtype) == 'interna') {
        return;
    }

    # OutboundPrefix needed?
    if ($(dlg_var(outboundPrefix){s.len})) {
        # OutboundPrefix dialed?
        if (!pcre_match("$rU", "^$dlg_var(outboundPrefix)")) {
            if ($dlg_var(log)) xlog("L_WARN", "OUTBOUND-PREFIX: Outbound call without outbound prefix $dlg_var(outboundPrefix), forbidden\n");
            send_reply("403", "Forbidden, $dlg_var(outboundPrefix) prefix needed");
            exit;
        }
    }

    return;
}

route[TRANSFORMATE_CALLER_OUT] {
    if ($dlg_var(subtype) == 'interna') {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: Skipping caller-out transformation for internal call from $fU\n");
        return;
    }

    # Where is my caller? PAI/RPID/From?
    if (is_present_hf("P-Asserted-Identity")) {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: PAI present: $(ai{uri.user})\n");
        $var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: RPID present: $(re{uri.user})\n");
        $var(caller) = $(re{uri.user});
    } else {
        if ($dlg_var(log)) xlog("L_WARN", "TRANSFORMATE-CALLER_OUT: Nor PAI nor RPID present, only From ($fU)! :(\n");
        $var(caller) = $fU;
    }

    # Analyze and apply necessary fixes to PAI/RPID/From
    if ($dlg_var(company_cc) == $dlg_var(user_cc)) {
        if (pcre_match("$var(caller)", "^00$dlg_var(company_cc)")) {
            if ($dlg_var(log)) xlog("L_WARN", "TRANSFORMATE-CALLER_OUT: ProxyTrunks didn't do its jobs?? Remove 00 + $dlg_var(company_cc)\n");
            $var(caller) = $(var(caller){s.strip,2}); # Remove 00
            $var(caller) = $(var(caller){s.strip,$(dlg_var(company_cc){s.len})}); # Remove company_cc
        } else if (pcre_match("$var(caller)", "^00")) {
            if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: International caller, proceed\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: Local caller, proceed\n");
        }
    } else {
        if (pcre_match("$var(caller)", "^00$dlg_var(company_cc)")) {
            if ($dlg_var(log)) xlog("L_WARN", "TRANSFORMATE-CALLER_OUT: ProxyTrunks didn't do its jobs?? Remove 00 + $dlg_var(company_cc)\n");
            $var(caller) = $(var(caller){s.strip,2}); # Remove 00
            $var(caller) = $(var(caller){s.strip,$(dlg_var(company_cc){s.len})}); # Remove company_cc
        } else if (pcre_match("$rU", "^00$dlg_var(user_cc)")) {
            if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: Local call for user, remove 00 + $dlg_var(user_cc) and proceed\n");
            $var(caller) = $(var(caller){s.strip,2}); # Remove 00
            $var(caller) = $(var(caller){s.strip,$(dlg_var(user_cc){s.len})}); # Remove user_cc
        } else if (pcre_match("$rU", "^00")) {
            if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: International caller, proceed\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: Local call for company, international for user. Add 00 + $dlg_var(company_cc) and proceed\n");
            $var(caller) = '00' + $dlg_var(company_cc) + $var(caller);
        }
    }

    # Add outbountPrefix if necessary
    if ($(dlg_var(outboundPrefix){s.len})) $var(caller) = $dlg_var(outboundPrefix) + $var(caller);

    # Set final caller in corresponding header
    if (is_present_hf("P-Asserted-Identity")) {
        remove_hf("Remote-Party-ID"); # If PAI present, RPID out
        remove_hf("P-Asserted-Identity");
        append_hf("P-Asserted-Identity: <sip:$var(caller)@$(ai{uri.host})>\r\n");
    } else if (is_present_hf("Remote-Party-ID")) {
        remove_hf("Remote-Party-ID");
        append_hf("Remote-Party-ID: <sip:$var(caller)@$(re{uri.host})>\r\n");
    } else {
        $fU = $var(caller);
    }

    if ($dlg_var(log)) xlog("L_INFO", "TRANSFORMATE-CALLER_OUT: Final caller -> $var(caller)\n");
    return;
}

route[RTPRELAY] {
#!ifdef WITH_RTPENGINE
    route(RTPENGINE);
#!else
    route(RTPPROXY);
#!endif
}

#!ifndef WITH_RTPENGINE
route[RTPPROXY] {
    if (has_body("application/sdp") && nat_uac_test("8")) {
        if ($dlg_var(log)) xlog("L_INFO", "RTPPROXY: Private IPs in SDP found, do not trust SDP addresses\n");
        rtpproxy_manage("cowf");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "RTPPROXY: No private IPs in SDP, trust SDP addresses\n");
        rtpproxy_manage("coarf");
    }

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_ERR", "RTPPROXY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }
}
#!endif

#!ifdef WITH_RTPENGINE
route[RTPENGINE] {
    $var(common_opts) = 'replace-session-connection replace-origin asymmetric trust-address force';

    if (is_request()) {
        # FIXME Elegir mejor opcion
        # Forma 1: guardando ulattrs=>transport en el save y recuperandolo en el lookup
        if ($xavp(ulattrs=>transport) == 'ws' | $xavp(ulattrs=>transport) == 'wss') {
            if ($dlg_var(log)) xlog("L_INFO", "RTPENGINE: Calling to WS subscriber: rtpengine_manage [$var(common_opts) ICE=force RTP/SAVPF DTLS=passive]\n");
            rtpengine_manage("$var(common_opts) ICE=force RTP/SAVPF DTLS=passive");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "RTPENGINE: Calling to non-WS subscriber: rtpengine_manage [$var(common_opts) ICE=remove RTP/AVP DTLS=no]\n");
            rtpengine_manage("$var(common_opts) ICE=remove RTP/AVP DTLS=no");
        }

        # Forma 2: analizando parametro transport del R-RURI
        $var(ruri_transport) = $(ru{uri.param,transport});
        if ($var(ruri_transport) == 'ws' || $var(ruri_transport) == 'wss') {
            if ($dlg_var(log)) xlog("L_INFO", "RTPENGINE: $var(ruri_transport) detected as R-URI transport [$var(common_opts) ICE=force RTP/SAVPF DTLS=passive]\n");
            #rtpengine_manage("$var(common_opts) ICE=force RTP/SAVPF DTLS=passive");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "RTPENGINE: non-WS or WSS detected as R-URI transport [$var(common_opts) ICE=remove RTP/AVP DTLS=no]\n");
            #rtpengine_manage("$var(common_opts) ICE=remove RTP/AVP DTLS=no");
        }
    } else {
        $var(via_transport) = @via[2].transport; # 2nd Topmost Via header transport (excluding myself)
        if ($dlg_var(log)) xlog("L_INFO", "RTPENGINE: Next hop uses $var(via_transport) as transport (2nd topmost Via header)\n");
        if ($var(via_transport) == 'WS' || $var(via_transport) == 'WSS') {
            if ($dlg_var(log)) xlog("L_INFO", "RTPENGINE: $var(via_transport) detected as Via transport [$var(common_opts) ICE=force RTP/SAVPF DTLS=passive]\n");
            rtpengine_manage("$var(common_opts) ICE=force RTP/SAVPF DTLS=passive");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "RTPENGINE: $var(via_transport) detected as Via transport [$var(common_opts) ICE=remove RTP/AVP DTLS=no]\n");
            rtpengine_manage("$var(common_opts) ICE=remove RTP/AVP DTLS=no");
        }
    }
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp != WEBSOCKETS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP request received on $Rp\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTP Request Received from $si:$sp\n");

    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
            if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Bad host $hdr(Host)\n");
            xhttp_reply("403", "Forbidden, bad host", "", "");
            exit;
        }

        # Optional... validate Origin - make sure the client is from an
        # authorised website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake()) {
            # Optional... cache some information about the
            # successful connection
            if ($sel(cfg_get.dolog.websocket)) xlog("L_NOTICE", "Connection upgrade was successful, oh yeah!\n");
            exit;
        }
    }

    xhttp_reply("404", "Not found", "", "");
}
#!endif

event_route[dispatcher:dst-down] {
    if ($dlg_var(log)) xlog("L_ERR", "Destination down: $rm $ru ($du)\n");
}

event_route[dispatcher:dst-up] {
    if ($dlg_var(log)) xlog("L_ERR", "Destination up: $rm $ru\n");
}


#!KAMAILIO

#########################################################################################################
#
#        IRONTEC - OASIS // Kamailio Proxy for Users
#        vozip@irontec.com
#
#########################################################################################################

####### Defines #########

#!define XMLRPC_PORT 8000
#!define WS_PORT 10080
#!define WSS_PORT 10081

#
# - flags
#   FLT_ - per transaction (message) flags
#   FLB_ - per branch flags
#   FLS_ - script flags
#   DLG_ - dialog flags

# FTL_NATS: Marca toda la transaccion como "tras NAT". Se comprueba al entrar una request.
# Se marca en 2 casos con la ayuda de la funcion nat_uac_test(19):
# 1. El contact tiene una IP privada
# 2. received_ip o received_port diferentes de los del Via
#
#!define FLT_NATS 5

# FLB_NATB: Marca el branch como "tras NAT".
# Se marca en 3 casos:
# 1. INVITE initial requests con uri!=myself (INVITE desde ASes) ---> Para tocar el contact?
# 2. En REGISTER tras NAT (hace que el registro guarde received)
# 3. Within-dialog requests con nat=yes en Route (a√±adido por nosotros en el INVITE que inicia este dialog si tras NAT)
#
#!define FLB_NATB 6

# FLB_NATSIPPING: Habilita el SIP ping via OPTIONS de terminales que se registran tras NAT (ver caso 2 FLB_NATB)
#!define FLB_NATSIPPING 7

# DLG_FLAG
#!define DLG_FLAG 8

# ACC Flags
#!define FLT_ACC 9
#!define FLT_ACCMISSED 10

# RELATED Flag (when set, aleg found for this call in this proxy)
#!define FLT_ISBLEG 11

#!define FLT_ACCFAILED 12

#!define FLB_WEBSOCKETS 13

# - options
#!define WITH_ANTIFLOOD

##!define KIND_MEDIALIBERATION
# Note: If defined, enable hack that avoids forwarding media liberation reINVITEs to endpoints

#!define DBURL "mysql://kamailio:ironsecret@data/ivozprovider"

#!define REGISTER_TIMEOUT 300

####### Runtime cfg values (kamcmd cfg.list) #########

# Log dialogs initiated by these SIP methods
dolog.invite    = 1 desc "If 1, log invite transactions"
dolog.register  = 1 desc "If 1, log register transactions"
dolog.publish   = 1 desc "If 1, log publish transactions"
dolog.subscribe = 1 desc "If 1, log subscribe transactions"
dolog.notify    = 1 desc "If 1, log notify transactions"
dolog.options   = 1 desc "If 1, log options transactions"
dolog.message   = 1 desc "If 1, log message transactions"
dolog.refer     = 1 desc "If 1, log refer transactions"
dolog.websocket = 1 desc "If 1, debug WS connection upgrade"

# Debug
dolog.xmlrpc    = 0 desc "If 1, debug XMLRPC"
dolog.printmsg_methods = 'NONE' desc "Print full SIP messages with these methods" # e.g. 'INVITE|REGISTER', 'NONE' to disable

####### Global Parameters #########

listen=udp:IP:5060
listen=tcp:IP:5060
listen=tls:IP:5061
listen=tcp:IP:XMLRPC_PORT
listen=tcp:IP:WS_PORT
listen=tls:IP:WSS_PORT

tcp_accept_no_cl=yes # Needed for WS

# -- Debug level
debug=2
memdbg=4
memlog=5

log_stderror=no
fork=yes

# Enable asynchronous framework (for delayed ACC inserts)
async_workers=4

# -- TCP params
disable_tcp=no
tcp_connection_lifetime=3605
tcp_connect_timeout=5
tcp_crlf_ping=yes
tcp_accept_aliases=no
tcp_async=yes
tcp_keepalive=yes
tcp_keepidle=5

enable_tls=yes

auto_aliases=no

log_facility=LOG_LOCAL0

# onsend_route block is executed for received replies that are sent out
onsend_route_reply=yes

# Add custom Server header
server_header="Server: Irontec Ivoz Provider v1.0"
user_agent_header="User-Agent: Irontec Ivoz Provider v1.0"

####### Modules Section ########

mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule    "tls.so"
loadmodule    "tm.so"
loadmodule    "tmx.so"
loadmodule    "pv.so"
loadmodule    "ctl.so"
loadmodule    "xlog.so"
loadmodule    "mi_fifo.so"
loadmodule    "mi_rpc.so"
loadmodule    "statistics.so"
loadmodule    "maxfwd.so"
loadmodule    "sl.so"
loadmodule    "kex.so"
loadmodule    "usrloc.so"
loadmodule    "registrar.so"
loadmodule    "siputils.so"
loadmodule    "rr.so"
loadmodule    "nathelper.so"
loadmodule    "textops.so"
loadmodule    "textopsx.so"
loadmodule    "db_mysql.so"
loadmodule    "sanity.so"
loadmodule    "avpops.so"
loadmodule    "permissions.so"
loadmodule    "sqlops.so"
loadmodule    "cfg_rpc.so"
loadmodule    "acc.so"
loadmodule    "dialog.so"
loadmodule    "htable.so"
loadmodule    "sdpops.so"
loadmodule    "auth.so"
loadmodule    "auth_db.so"
loadmodule    "domain.so"
loadmodule    "xmlrpc.so"
loadmodule    "xmlops.so"
loadmodule    "regex.so"
loadmodule    "dispatcher.so"
loadmodule    "debugger.so"
loadmodule    "corex.so"
loadmodule    "ndb_redis.so"
loadmodule    "rtpengine.so"
loadmodule    "websocket.so"
loadmodule    "xhttp.so"
loadmodule    "jsonrpc-s.so"
loadmodule    "json.so"
loadmodule    "rtpproxy.so"

#!ifdef WITH_ANTIFLOOD
loadmodule    "pike.so"
#!endif

# RTPENGINE
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:22223")

# RTPPROXY
modparam("rtpproxy", "db_url", DBURL)
modparam("rtpproxy", "table_name", "kam_rtpproxy")
modparam("rtpproxy", "rtp_inst_pvar", "$var(RTP_INSTANCE)")
modparam("rtpproxy", "nortpproxy_str", "a=sdpmangled:yes\r\n")

# REDIS
modparam("ndb_redis", "server", "name=redis;addr=jobs.ivozprovider.local;port=6379")
modparam("ndb_redis", "init_without_redis", 1)

# DEBUGGER
modparam("debugger", "mod_hash_size", 5)
modparam("debugger", "mod_level_mode", 1)

# DISPATCHER
modparam("dispatcher", "db_url", DBURL)
modparam("dispatcher", "table_name", "kam_dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dstid_avp", "$avp(AVP_DSTID)")
modparam("dispatcher", "ds_hash_size", 9)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "ds_ping_interval", 30)
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=404;code=401")
modparam("dispatcher", "ds_ping_from", "sip:dispatcher@users.ivozprovider.local")

# CTL
modparam("ctl", "binrpc", "unix:/tmp/kamailio_proxyusers_ctl")

# TLS
modparam("tls", "config", "/etc/kamailio/proxyusers/tls.cfg")
modparam("tls", "tls_log", 2)

# MI_FIFO
modparam("mi_fifo", "fifo_name", "/tmp/kamailio_proxyusers_fifo")

# USRLOC
modparam("usrloc", "use_domain", 1)
modparam("usrloc", "nat_bflag", FLB_NATB)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "db_url", DBURL)
modparam("usrloc|tm", "xavp_contact", "ulattrs")

# RR
modparam("rr","enable_double_rr", 1)
modparam("rr", "append_fromtag", 1)

# XLOG
modparam("xlog", "log_facility", "LOG_LOCAL1")
modparam("xlog", "prefix", "")

# L_ALERT  - log level -5
# L_BUG    - log level -4
# L_CRIT   - log level -3
# L_ERR    - log level -1
# L_WARN   - log level  0
# L_NOTICE - log level  1
# L_INFO   - log level  2
# L_DBG    - log level  3

# El parametro clave es debug (por defecto a 2 en este cfg)
# Se imprime todo lo que tenga <= que este valor (valores posibles: 0 - infinito)
# 0: De WARN (incluido) para arriba
# 1: De NOTICE (incluido) para arriba
# 2: De INFO (incluido) para arriba
# 3: De DBG (incluido) para arriba
#
# Se puede modificar on-the-fly con:
# kamcmd cfg.seti core debug X
# Y obtener el valor actual con:
# kamcmd cfg.get core debug

# NAT
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")

# REGISTER
modparam("registrar", "max_expires", REGISTER_TIMEOUT)
modparam("registrar", "max_contacts", 5)

# PERMISSIONS
modparam("permissions", "db_url", DBURL)
modparam("permissions", "address_table", "kam_users_address") # Allowed networks per company
modparam("permissions", "trusted_table", "kam_pike_trusted") # IPs excluded from pike checking
modparam("permissions", "db_mode", 1)
modparam("permissions", "grp_col", "companyId")

# ACC
modparam("acc", "early_media", 1)
modparam("acc", "report_ack", 1) # Only for successful establishments
modparam("acc", "report_cancels", 1)
modparam("acc", "detect_direction", 0)
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
modparam("acc", "time_mode", 4)
modparam("acc", "time_attr", "utctime")
modparam("acc", "time_format", "%Y-%m-%d %H:%M:%S")
modparam("acc", "acc_time_column", "localtime")

# -- to syslog
modparam("acc", "log_facility", "LOG_LOCAL2")
modparam("acc", "log_level", 2)
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd ; cseq=$cs")

# -- to database
modparam("acc", "db_url", DBURL)
modparam("acc", "db_insert_mode", 2)
modparam("acc", "db_table_acc", "kam_users_acc")
modparam("acc", "db_table_missed_calls", "kam_users_missed_calls")
modparam("acc", "cdrs_table", "kam_acc_cdrs")
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_extra", "from_user=$fU; from_domain=$fd; src_ip=$si; ruri_user=$rU; ruri_domain=$rd; cseq=$cs")

# -- cdr accounting
modparam("acc", "cdr_enable", 1)
modparam("acc", "cdr_log_enable", 1)
modparam("acc", "cdr_on_failed", 0)
modparam("acc", "cdr_expired_dlg_enable", 1)
modparam("acc", "cdr_start_on_confirmed", 1)
modparam("acc", "cdr_facility", "LOG_LOCAL3")
modparam("acc", "cdr_extra", "proxy=$dlg_var(proxy);brandId=$dlg_var(brandId);companyId=$dlg_var(companyId);caller=$dlg_var(caller);callee=$dlg_var(callee);callid=$dlg_var(callid);callidHash=$dlg_var(cidhash);xcallid=$dlg_var(xcallid);diversion=$dlg_var(diversion);referrer=$dlg_var(referrer);referee=$dlg_var(referee);direction=$dlg_var(direction)")

# DIALOG
modparam("dialog", "dlg_flag", DLG_FLAG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "rr_param", "did")
modparam("dialog", "profiles_with_value", "activeCalls; internalCalls; inboundExtCalls; outboundExtCalls")
# Destruye dialogo si no hay BYE (se reinicia a cada request)
#modparam("dialog", "default_timeout", 21600)
#modparam("dialog", "default_timeout", 90)
modparam("dialog", "send_bye", 1)
modparam("dialog", "enable_stats", 1)
# Las incluye en mensajes creados por el modulo dialog (BYEs)
modparam("dialog", "dlg_extra_hdrs", "Hint: inactivity timeout\r\n")
# Keep-alive (in-dialog OPTIONs)
#modparam("dialog", "ka_timer", 10)
#modparam("dialog", "ka_interval", 300)

# TM
modparam("tm", "fr_timer", 5000)
# enable serial/parallel forking
modparam("tm", "contacts_avp", "tm_contacts")
modparam("tm", "contact_flows_avp", "tm_contact_flows")
modparam("tm", "local_cancel_reason", 200)

# AUTH_DB
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "password")
modparam("auth_db", "domain_column", "domain")
modparam("auth_db", "use_domain", 1)
#modparam("auth_db", "load_credentials", "") # Interesante para cargar AVP per subscriber

#!ifdef WITH_ANTIFLOOD
# PIKE
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 30)
modparam("pike", "remove_latency", 120)

# HTABLE
# ip ban htable with autoexpire after 5 minutes
modparam("htable", "htable", "ipban=>size=8;autoexpire=300")
#!endif

modparam("htable", "htable", "dialogs=>size=10;autoexpire=0")

# SANITY
modparam("sanity", "autodrop", 0)

# SQL OPS
modparam("sqlops","sqlcon","cb=>mysql://kamailio:ironsecret@data/ivozprovider")

# DOMAIN
modparam("domain", "db_url", DBURL)
modparam("domain", "domain_table", "kam_users_domain")
modparam("domain", "domain_attrs_table", "kam_users_domain_attrs")
modparam("domain", "register_myself", 1)

# XMLRPC
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC2")

####### Routing Logic ########

request_route {
    route(CONFIGURE_XLOG);

    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Request: '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");

    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) xlog("L_WARN", "Received message:\n\n$mb\n");

    if (is_method("OPTIONS")) {
        if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Send 200 to '$rm $ru' ('$cs $rm') from '$fu' ($si:$sp) [$proto]\n");
        send_reply("200", "I'm here!");
        exit;
    }

    # per request initial checks
    route(REQINIT);

    # NAT/WS detection
    if (nat_uac_test(64)) # 64 - Test if the source connection of signaling is WS
        route(WSDETECT);
    else
        route(NATDETECT);

    # CANCEL processing
    if (is_method("CANCEL")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si\n");
        if (t_check_trans()) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
            route(RELAY);
        }

        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ----> $rm from $si is not from a known transaction, drop\n");
        exit;
    }

    # IN DIALOG CHECK
    if (has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] In dialog request - has_to_tag\n");
        route(WITHINDLG);
    }

    ### only initial requests (no To tag)

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NOT in dialog request - not has_to_tag: Initial transaction\n");

    # Manage retransmissions
    t_check_trans();

    # Discard unsupported methods
    if (!is_method("INVITE|REGISTER|SUBSCRIBE|NOTIFY|PUBLISH")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rm not supported\n");
        send_reply("501", "Not Implemented");
        exit;
    }

    # Manage authentication
    route(AUTH);

    # Remove preloaded route headers
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Remove preloaded route headers\n");
    remove_hf("Route");

    # Handle everything except INVITEs
    if(is_method("REGISTER")) {
        route(REGISTER);
    } else if(is_method("SUBSCRIBE")) {
        route(SUBSCRIBE);
    } else if(is_method("NOTIFY")) {
        route(NOTIFY);
    } else if(is_method("PUBLISH")) {
        route(PUBLISH);
    }

    # From now on, everything is for INVITEs: track dialog

    # Setup accounting
    route(ACCOUNTING);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog_manage()\n");
    dlg_manage();

    #dlg_set_property("ka-src");
    #dlg_set_property("ka-dst");

    # Add record-route to INVITE requests
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Add record-route\n");
    record_route();

    # uri!=myself:
    # (a) from_uri==myself: Local subscriber calling to external domain
    # (b) from_uri!=myself: Trusted host with incorrect domain in R-URI
    if (uri!=myself) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] R-URI not for my domain\n");
        if (from_uri==myself) {
            # (a) Local subscriber calling to external domain
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Local subscriber calling to external domain, 501 Not implemented\n");
            send_reply("501", "Not Implemented");
            exit;
        } else {
            # (b) Trusted host with incorrect domain in R-URI
            # Solo puede llegar aqui alguien que haya superado ds_is_from_list("1") en AUTH,
            # porque si no se habria descartado por open relay

            # Desde el cambio de ser location server, AS no deberia escribir sin mi dominio en el R-URI
            if ($dlg_var(log)) xlog("L_ERR", "AS talking with incorrect domain in R-URI ($ru), check!!\n");
            send_reply("500", "Invalid URI domain");
            exit;
        }
    }

    # uri==myself
    # (a) from_uri==myself: Local subscriber calling to my domain
    # (b) from_uri!=myself:
    #   (b1) AS
    #   (b2) DROP
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] R-URI: My domain\n");

    if (from_uri==myself) {
        $dlg_var(direction) = 'inbound';

        # (a) from_uri==myself: Local subscriber calling to my domain
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Local subscriber calling to my domain, dispatch to AS(-es)\n");
        route(DIALOGS_GET_INFO);
        route(GET_INFO_FROM_TERMINAL);
        route(FILTER_BY_SCR_ADDR);
        if ($rU =~ '^\*') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calling to feature-like $rU, ringall all AS-es\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calling to non-feature-like $rU, dispatch to any AS\n");
            route(PROFILE_UAC_CALL);
        }

        # Redis data
        $dlg_var(AoR) = $fU + '@' + $fd;
        $dlg_var(interlocutor) = $rU;
        $dlg_var(redisset) = 'call::b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId) + 'e' + $dlg_var(caller) + '::' + $ci;

        route(DISPATCH);
        route(RELAY);
    } else {
        if (ds_is_from_list("1")) {
            $dlg_var(direction) = 'outbound';

            # Save CallID <-> AS relationship
            $sht(dialogs=>$ci::applicationserver) = 'sip:' + $si + ':6060';

            # (b1) AS calling to local subscriber
            route(REPLACES);
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AS calling to local subscriber, relay to subcriber\n");
            route(PARSE_X_HEADERS);
            route(RELATE_LEGS);
            route(LOOKUP);
            route(PROFILE_AS_CALL);

            # Redis data
            $dlg_var(AoR) = $tU + '@' + $td;
            $dlg_var(interlocutor) = $(ai{uri.user});
            $dlg_var(redisset) = 'call::b' + $dlg_var(brandId) + 'c' + $dlg_var(companyId) + 'e' + $dlg_var(callee) + '::' + $ci;

            route(RELAY);
        } else {
            # (b2) from_uri!=myself: Who is calling?? ProxyUsers only receives from subscribers and AS-es -> Drop
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Who is calling?? ProxyUsers only receives from subscribers and AS-es -> Drop\n");
            send_reply("403", "Forbidden");
            exit;
        }
    }

    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Main script error, should NOT arrive this point.\n");
    drop;
}

route[REPLACES] {
    if (! is_present_hf("Replaces")) return;

    # AS sending an INVITE with REPLACE header, guess which AS is the proper destination
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: AS sending a INVITE with Replaces header, forward to proper AS\n");

    # Extract CallId from Replaces header
    $var(replace_uri) = $(hdr(Replaces){s.select,0,;});
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Which AS is handling $(hdr(Replaces){s.select,0,;})?\n");

    if ($sht(dialogs=>$var(replace_uri)::applicationserver) != $null) {
        $du = $sht(dialogs=>$var(replace_uri)::applicationserver);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: Forward to '$du'\n");
        $fu = 'sip:replacer@users.ivozprovider.local'; # Change From header too
        route(RELAY);
    } else {
        if ($dlg_var(log)) xlog("L_ERROR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPLACES: CallID not found, 500\n");
        send_reply("500", "CallID not found");
        exit;
    }
    # Note: this dialog won't be inserted into kam_acc_cdrs (INSERT fails) and that's OK
}

route[DISPATCH] {
    # Insert header with LogTag
    insert_hf("X-Info-Logtag: b$dlg_var(brandId)\r\n");

    # Strict routing to specific AS?
    if ($avp(asAddress) != $null) {
        $du = "sip:" + $avp(asAddress) + ":6060";
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du> (strict routing)\n");
        t_on_failure("MANAGE_FAILURE");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: dispatch to any AS (loose routing)\n");

        # round robin dispatching on ASs
        if(!ds_select_dst("1", "10")) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: No destination found\n");
            send_reply("404", "No destination");
            exit;
        }

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DISPATCH: going to <$ru> via <$du>\n");
        t_on_failure("MANAGE_FAILURE_AS");
    }

    # Save CallID <-> AS relationship
    $sht(dialogs=>$ci::applicationserver) = $du;
}

route[LOOKUP] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Look up $ru on location DB\n");
    lookup("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contact not not found for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
        case -2:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contacts found, but method not supported for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
        case -3:
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Internal error during processing lookup for $ru, 404\n");
            sl_send_reply("404", "Not Found");
            exit;
    };

    # Handle multiple contacts
    if (!t_load_contacts()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Error loading contacts for $rU\n");
        sl_send_reply("500", "Server Internal Error - Cannot load contacts");
        exit;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: Contacts loaded for $rU\n");
    }

    # Load contact or contacts
    if (!t_next_contacts()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - Only one contact found for $rU, calling\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] LOOKUP: t_next_contacts - Multiple contacts found for $rU, parallel forking\n");
    }
}

route[GET_INFO_FROM_TERMINAL] {
    # Del nombre del terminal origen, saco todo lo necesario
    sql_xquery("cb", "SELECT EXT.number AS userExtension, C.id AS companyId, C.brandId AS brandId, C.name AS companyName, C.mediaRelaySetsId, C.ipFilter, AppS.ip AS asAddress, C.onDemandRecord, C.onDemandRecordCode FROM Terminals T LEFT JOIN Users U ON U.terminalId=T.id LEFT JOIN Extensions EXT ON EXT.Id=U.extensionId LEFT JOIN Companies C ON T.companyId=C.id LEFT JOIN ApplicationServers AppS ON AppS.id=C.applicationServerId WHERE T.name='$fU' AND T.domain='$fd'", "ra");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: caller: $xavp(ra=>userExtension)\n");
    $dlg_var(caller) = $xavp(ra=>userExtension);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: brandId: $xavp(ra=>brandId)\n");
    $dlg_var(brandId) = $xavp(ra=>brandId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: companyId: $xavp(ra=>companyId)\n");
    $dlg_var(companyId) = $xavp(ra=>companyId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: companyName: $xavp(ra=>companyName)\n");
    $dlg_var(companyName) = $xavp(ra=>companyName);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: ipFilter: $xavp(ra=>ipFilter)\n");
    $var(ipFilter) = $xavp(ra=>ipFilter);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: asAddress: $xavp(ra=>asAddress)\n");
    $avp(asAddress) = $xavp(ra=>asAddress);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: mediaRelaySetsId: $xavp(ra=>mediaRelaySetsId)\n");
    $dlg_var(mediaRelaySetsId) = $xavp(ra=>mediaRelaySetsId);

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: onDemandRecord: $xavp(ra=>onDemandRecord)\n");
    if ($xavp(ra=>onDemandRecord)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] GET-INFO-FROM-TERMINAL: onDemandRecordCode: $xavp(ra=>onDemandRecordCode)\n");
        $dlg_var(onDemandRecordCode) = $xavp(ra=>onDemandRecordCode);
    }
}

route[FILTER_BY_SCR_ADDR] {
    if ($var(ipFilter) == '0') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: IP filter is disabled for company $dlg_var(companyName) (id: $dlg_var(companyId))\n");
        return;
    }

    if (!allow_source_address($dlg_var(companyId))) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: $si is not valid for company $dlg_var(companyName) (id: $dlg_var(companyId))\n");
        $rU = 'ipnotallowed';
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] FILTER-BY-SCR-ADDR: Valid source $si for company $dlg_var(companyName) (id: $dlg_var(companyId))\n");
    }
}

route[PARSE_X_HEADERS] {
    # Extract xcallid
    $var(header) = 'X-Call-Id';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(xcallid) = $var(header-value);

    # Extract callee
    $var(header) = 'X-Info-Callee';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(callee) = $var(header-value);

    # Extract brandId
    $var(header) = 'X-Info-BrandId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(brandId) = $var(header-value);

    # Extract companyId
    $var(header) = 'X-Info-CompanyId';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyId) = $var(header-value);

    # Extract companyName
    $var(header) = 'X-Info-CompanyName';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyName) = $var(header-value);

    # Extract companyDomain
    $var(header) = 'X-Info-CompanyDomain';
    route(PARSE_MANDATORY_X_HEADER);
    $dlg_var(companyDomain) = $var(header-value);

    # Extract MediaRelaySet (can be null and non-exist)
    $var(header) = 'X-Info-MediaRelaySet';
    route(PARSE_OPTIONAL_X_HEADER);
    $dlg_var(mediaRelaySetsId) = $var(header-value);

    # Extract RecordCode (can be null and non-exist)
    $var(header) = 'X-Info-RecordCode';
    route(PARSE_OPTIONAL_X_HEADER);
    $dlg_var(onDemandRecordCode) = $var(header-value);
}

# Header might not be present and, if present, might be empty
route[PARSE_OPTIONAL_X_HEADER] {
    if (is_present_hf($var(header))) {
        if ($(hdr($var(header)){s.len})) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): $hdr($var(header))\n");
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header): <empty>\n");
        }
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-OPTIONAL-X-HEADER: $var(header) not present\n");
    }
}

# Header MUST be present and with not null value
route[PARSE_MANDATORY_X_HEADER] {
    if (is_present_hf($var(header)) && $(hdr($var(header)){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header): $hdr($var(header))\n");
        $var(header-value) = $hdr($var(header));
        remove_hf($var(header));
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PARSE-MANDATORY-X-HEADER: $var(header) not present or not valid, aborting\n");
        sl_send_reply("500", "Missing $var(header)");
        exit;
    }
}

route[PROFILE_UAC_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Type-> saliente\n");

    # Interna / Externa
    sql_xquery("cb", "SELECT COUNT(*) > 0 AS esInterna FROM Extensions E WHERE number='$rU' AND companyId='$dlg_var(companyId)'", "ra");
    if ($xavp(ra=>esInterna) == '1' || pcre_match("$rU", "^\*")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Subtype-> interna\n");
        # Internal calls will be profiled only in bleg (to avoid duplicates)
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Subtype-> externa\n");

        # Outbound external calls by company
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-UAC-CALL: Profile-> outboundExtCalls\n");
        $dlg_var(profile) = "Outbound external call";
        set_dlg_profile("outboundExtCalls", "$dlg_var(companyId)");

        # Active calls by company
        set_dlg_profile("activeCalls", "$dlg_var(companyId)");
    }
}

route[PRINT_STATS] {
    # Global stats
    if(get_profile_size("activeCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) active calls\n");
    }

    if(get_profile_size("internalCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) internal calls\n");
    }

    if(get_profile_size("outboundExtCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) external outbound calls\n");
    }

    if(get_profile_size("inboundExtCalls", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: Global stat: $avp(size) external inbound calls\n");
    }

    # Company stats
    if(get_profile_size("activeCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) active calls\n");
    }

    if(get_profile_size("internalCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) internal calls\n");
    }

    if(get_profile_size("outboundExtCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) external outbound calls\n");
    }

    if(get_profile_size("inboundExtCalls", "$dlg_var(companyId)", "$avp(size)")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: '$dlg_var(companyName)' (id: $dlg_var(companyId)): $avp(size) external inbound calls\n");
    }
}

route[PROFILE_AS_CALL] {
    # Saliente / Entrante
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Type-> entrante\n");

    # Interna / Externa
    if (isflagset(FLT_ISBLEG)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Subtype-> interna\n");

        # Internal calls by company
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Profile-> internalCalls\n");
        $dlg_var(profile) = "Internal call";
        set_dlg_profile("internalCalls", "$dlg_var(companyId)");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Subtype-> externa\n");

        # Inbound external calls by company
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PROFILE-AS-CALL: Profile-> inboundExtCalls\n");
        $dlg_var(profile) = "Inbound external call";
        set_dlg_profile("inboundExtCalls", "$dlg_var(companyId)");
    }

    # Active calls by company
    set_dlg_profile("activeCalls", "$dlg_var(companyId)");
}

# Authentication route
route[AUTH] {
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: No auth for AS request\n");
        return;
    }

    if (is_method("REGISTER") || from_uri==myself) {
        # authenticate requests
        if (!auth_check("$fd", "Terminals", "1")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Auth needed\n");
            auth_challenge("$fd", "0");
            exit;
        }

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] AUTH: Authentication OK, consume credentials\n");
        # user authenticated - remove auth header
        consume_credentials();
    }

    # if caller is not local subscriber, then check if it calls
    # a local destination, otherwise deny, not an open relay here
    if (from_uri!=myself && uri!=myself) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Not open relay here!\n");
        sl_send_reply("403","Not relaying");
        exit;
    }

    # Domain strict checking
    if ( uri == myself && !is_uri_host_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $rd is my IP but domains should be used, reject\n");
        sl_send_reply("488", "Domain needed");
        exit;
    }

    if ( from_uri == myself && !is_from_local() ) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] $fd is my IP but domains should be used, reject\n");
        sl_send_reply("488", "Domain needed");
        exit;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Domain strict checking success\n");

    return;
}

route[MEDIALIBERATION] {
#!ifdef KIND_MEDIALIBERATION
    if (is_method("ACK") && $dlg_var(discardack) == '1') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: Drop ACK, magic part 2 of 2!\n");
        $dlg_var(discardack) = $null;
        exit;
    }

    if (is_method("INVITE|UPDATE") && has_body("application/sdp") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: Re-$rm from AS, evaluate doing magic\n");
        if (!sdp_get_line_startswith("$avp(cline)", "c=IN IP4 " + $si)) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: RTPproxy on SDP, start magic!\n");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: Mangle RTPproxy ports and reply 200, magic part 1 of 2!\n");
            if (is_method("INVITE"))
                $dlg_var(discardack) = '1'; # Set dlg_flag to discard subsequent ACK
            route(RTPRELAY); # Call RTPRELAY to link ports accordingly
            send_reply("200", "I agree");
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MEDIALIBERATION: SDP does not contain RTPproxy ($avp(cline)), abort magic\n");
        }
    }
#!endif
    return;
}

# Handle within-dialog messages
route[WITHINDLG] {
    # Do not forward media liberation reinvite
    route(MEDIALIBERATION);

    # Update interlocutor
    if (is_present_hf("P-Asserted-Identity") && $(ai{uri.user})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: Update redis interlocutor to $(ai{uri.user})\n");
        redis_cmd("redis", "HMSET $dlg_var(redisset) interlocutor $(ai{uri.user})", "r");
    }

    # Subscribe requests do not follow loose routing
    if (is_method("SUBSCRIBE")) {
        remove_hf("Proxy-Authorization");
        if (uri==myself) {
            # Within dialog subscribe shouldn't have my domain in R-URI, loose routing is not possible!
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE loose-routing is not possible, fake!\n");
            if ($sht(dialogs=>$ci::subscribe_as) =~ '^sip:') {
                if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE from known dialog, forward to $sht(dialogs=>$ci::subscribe_as)\n");
                $ru = $sht(dialogs=>$ci::subscribe_as);
                route(RELAY);
            } else {
                if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE from unknown dialog, 481\n");
                send_reply("481", "Call/Transaction Does Not Exist");
                exit;
            }
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WITHINDLG: SUBSCRIBE loose-routing capable, proceed\n");
        }
    }

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
        route(RURIALIAS);
        if (is_method("BYE")) {
            setflag(FLT_ACC);       # do accounting
            setflag(FLT_ACCFAILED); # even if the transaction fails
        } else if (is_method("ACK")) {
            # ACK is forwarded statelessly
            route(NATMANAGE);
        } else if (is_method("REFER")) {
            route(REFER);
        } else if (is_method("INFO")) {
            route(INFO);
        } else if (is_method("NOTIFY")) {
            # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
            record_route();
        }
        route(RELAY);
    } else {
        if (is_method("ACK")) {
            if ( t_check_trans() ) {
                # no loose-route, but stateful ACK;
                # must be an ACK after a 487
                # or e.g. 404 from upstream server
                route(RELAY);
                exit;
            } else {
                # ACK without matching transaction ... ignore and discard
                exit;
            }
        }
        sl_send_reply("404","Not here");
    }
    exit;
}

route[REFER] {
    if (is_present_hf("Refer-to") && $(hdr(Refer-to){s.len})) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: $fU transfers call to $hdr(Refer-to)\n");

        if ($(hdr(Refer-to){nameaddr.uri}{uri.user}) =~ '^,?\*[0-9]{1,3}$') {
            route(ONDEMANDRECORD);
        }

        $dlg_var(referee) = $hdr(Refer-to);
    } else {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REFER: No Refer-To header found, error\n");
        send_reply("400", "Refer-To is missing");
        exit;
    }
}

route[INFO] {
    if (is_present_hf("Record")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] On demand record using INFO, proceed\n");
        route(ONDEMANDRECORD);
    }

    return;
}

route[ONDEMANDRECORD] {
    if (!$dlg_var(onDemandRecordCode)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: On demand record not enabled, ignore\n");
        send_reply("403", "Forbidden");
        exit;
    }

    if (is_method("REFER")) {
        $var(opt1) = ',*' + $dlg_var(onDemandRecordCode);
        $var(opt2) = '*' + $dlg_var(onDemandRecordCode);
        $var(code) = $(hdr(Refer-to){nameaddr.uri}{uri.user});

        if ($var(code) != $var(opt1) && $var(code) != $var(opt2)) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: That is NOT the code, ignore\n");
            send_reply("403", "Forbidden");
            exit;
        }
    }

    if ($dlg_var(recording) != 'yes') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Start recording call\n");
        start_recording();
        $dlg_var(recording) = 'yes';
        send_reply("404", "Record On");
    } else {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ONDEMANDRECORD: Start recording code again, do nothing\n");
        send_reply("404", "Record Already On");
    }
    exit;
}

# URI update for requests where alias found
route[RURIALIAS] {
    if(isdsturiset()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Destination URI is set, no un-aliasing is needed\n");
        return;
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Route using R-URI, any alias on R-URI ('$ru')?\n");

    handle_ruri_alias();
    switch ($rc) {
    case -1:
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Failed to handle alias of R-URI $ru\n");
        send_reply("400", "Bad request");
        exit;
    case 1:
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Alias parsed, routing $rm from $fu to $du\n");
        break;
    case 2:
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RURIALIAS: Alias not found, routing $rm from $fu to $ru\n");
        break;
    };

    return;
}

# Relay request
route[RELAY] {
    # Common for every transaction
    t_on_reply("MANAGE_REPLY");
    t_on_branch("MANAGE_BRANCH");

    # Only for non-initial transaction and for UAC initial (AS initial has custom route)
    if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");

    if (!t_relay())
        sl_reply_error();

    exit;
}

# Initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
    # flood detection from same IP and traffic ban for a while
    #
    # Excluded from pike:
    #   - my ip excluded
    #   - AS-es excluded
    #   - IPs in trusted table
    #   - Authorized IPs for companies
    $var(group) = allow_address_group($si, $sp);
    if ($var(group) != -1) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (allowed source for companyId '$var(group)')\n");
    } else if (allow_trusted($si, 'any')) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (IP added in antiflood trusted IPs)\n");
    } else if (src_ip==myself || ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si is not checked against antiflood (AS or myself talking)\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si will be checked against antiflood\n");
        if($sht(ipban=>$si) != $null) {
            # ip is already blocked
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
            exit;
        }
        if (!pike_check_req()) {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
            $sht(ipban=>$si) = 1;
            exit;
        }
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: $si granted by antiflood\n");
    }
#!endif

    # Max forwards?
    if (!mf_process_maxfwd_header("10")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: Too many hops for SIP message from $si:$sp\n");
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    # Malformed SIP message?
    if(!sanity_check("1511", "7")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: Malformed SIP message from $si:$sp\n");
        exit;
    }

    # Easy dropping for sipvicious scans
    if (search("sipvicious")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: DROPPED SIPVICIOUS ----> $rm from $si\n");
        exit;
    }
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REQINIT: All checks passed, continue...\n");
}

# Handle SIP registrations
route[REGISTER] {
    if(isflagset(FLT_NATS)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: NAT must be kept open\n");
        setbflag(FLB_NATB);
        # Enable SIP NAT pinging
        if ($proto == 'udp') {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable UDP SIP OPTIONS PINGING\n");
            setbflag(FLB_NATSIPPING);
        } else {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Enable TCP raw NAT keeper\n");
        }
    }

    # Store in kam_users_location_attrs used transport to retrieve it in lookup
    $xavp(ulattrs=>transport) = $proto;

    $var(contact_uri) = @contact.uri;
    save("kam_users_location");
    switch ($?) {
        case -1:
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Something went wrong when saving location\n");
            sl_reply_error();
            break;
        case 1:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts inserted ($tu: $var(contact_uri))\n");
            break;
        case 2:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts updated ($tu: $var(contact_uri))\n");
            break;
        case 3:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts deleted ($tu: $var(contact_uri))\n");
            break;
        case 4:
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REGISTER: Contacts returned\n");
            break;
    };

    exit;
}

# Handle SUBSCRIBE messages
route[SUBSCRIBE] {
    # Only UACs can send SUBSCRIBE requests
    if (ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SUBSCRIBE: Received $rm from AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # I only handle my domains
    if (uri!=myself) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SUBSCRIBE: Received $rm to an incorrect domain $rd, 404 Not Here\n");
        send_reply("404", "Not here");
        exit;
    }

    # Add record-route to SUBSCRIBE requests
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SUBSCRIBE: Add record-route\n");
    record_route();

    # Dispatch SUBSCRIBE to any AS
    route(GET_INFO_FROM_TERMINAL);
    route(DISPATCH);

    # Save selected AS for routing in-dialog requests
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] SUBSCRIBE: Save subscribe_as for created dialog\n");
    $sht(dialogs=>$ci::subscribe_as) = $du;

    route(RELAY);
}

# Handle NOTIFY messages
route[NOTIFY] {
    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NOTIFY: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Lookup contact and relay
    route(LOOKUP);
    route(RELAY);
}

# Handle PUBLISH messages
route[PUBLISH] {
    if (!ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PUBLISH: Received $rm from not AS, 405 Method Not Allowed\n");
        send_reply("405", "Method Not Allowed");
        exit;
    }

    # Republish to remaining AS-es
    route(REPUBLISH);
}

route[REPUBLISH] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: Send PUBLISH from $si to remaining AS-es\n");

    sl_send_reply("200", "OK, republishing");
    t_release();

    if(!ds_select_dst("1", "4")) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: No destination found\n");
        exit;
    }

    $var(i)¬†=¬†0;
    while(is_avp_set("$(avp(AVP_DST)[$var(i)])"))¬†{
        $du = $(avp(AVP_DST)[$var(i)]);
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: Forward[$var(i)]: $du\n");
        route(AVOID_SRC);

        $var(i)¬†=¬†$var(i)¬†+¬†1;
    }

    exit;
}

route[AVOID_SRC] {
    if ($(du{s.select,1,:}) == $si) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: not sending to original source, skip\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] REPUBLISH: destination found, going to <$ru> via <$du>\n");
        forward();
    }
}

# Detect NAT
route[NATDETECT] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Force rport\n");
    force_rport();

    # 19: 1 + 2 + 16
    # 1 - The "Contact" header field is searched for occurrence of RFC1918 or RFC6598 addresses.
    # 2 - the "received" test is used: address in the "Via" header is compared against source IP address of signaling
    # 16 - Test if the source port is different from the port in the "Via" header
    if (nat_uac_test("19")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: NAT detected, set FLT_NATS\n");
        setflag(FLT_NATS);

        if (is_method("REGISTER")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: REGISTER ---> fix_nated_register\n");
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Non-REGISTER and first hop ---> Add contact alias\n");
                # Sets ;alias only if received ip and port differ from those in contact URI
                if (!add_contact_alias()) {
                   if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: Error in aliasing contact $ct\n");
                   send_reply("400", "Bad request");
                   exit;
                }
            }
        }
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATDETECT: No NAT detected\n");
    }
}

route[WSDETECT] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSDETECT: Websockets detected, fix contact\n");
    # Do NAT traversal stuff for requests from a WebSocket
    # connection - even if it is not behind a NAT!
    # This won't be needed in the future if Kamailio and the
    # WebSocket client support Outbound and Path.
    force_rport();
    if (is_method("REGISTER")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSDETECT: Add Received AVP to be stored by userloc with $proto:$si:$sp\n");
        fix_nated_register();
    } else if (!add_contact_alias()) {
        if($dlg_var(nolog) != "1") xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] WSDETECT: Error aliasing contact <$ct>\n");
        sl_send_reply("400", "Bad Request");
        exit;
    }
    return;
}

# Handle NAT
route[NATMANAGE] {
    # RTP handling is always enforced
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Force RTPRELAY\n");
    route(RTPRELAY);

    # Set FLB_NATB? Only in within-dialog request with nat=yes on Route header
    if (is_request() && has_totag() && check_route_param("nat=yes")) {
       if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Set FLB_NATB (reason: within-dialog request with nat=yes on Route header)\n");
       setbflag(FLB_NATB);
    }

    # Return unless FLT_NATS or FLB_NATB are set
    if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: No endpoint is behind NAT, return\n");
        return;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: One or both endpoints are behind NAT, continue!\n");
    }

    # Add nat=yes in record-route? Only in initial requests when called from branch_route
    if (is_request() && !has_totag() && t_is_branch_route()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Add nat=yes to record-route (reason: initial request called from branch route)\n");
        add_rr_param(";nat=yes");
    }

    # Add contact alias? Only to replies with NATB set and first hop
    if (is_reply() && isbflagset(FLB_NATB) && is_first_hop()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Add contact alias (reason: reply with NATB set and first hop)\n");
        # Sets ;alias only if received ip and port differ from those in contact URI
        if (!add_contact_alias()) {
           if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] NATMANAGE: Error in aliasing contact $ct\n");
           send_reply("400", "Bad request");
           exit;
        }
    }
}

# Configure xlog
route[CONFIGURE_XLOG] {
    # Evaluate only once for SIP methods than can initiate transaction
    if ($dlg_var(log) == "0" || $dlg_var(log)) return;

    $dlg_var(log) = "0";

    if (is_method("INVITE") && $sel(cfg_get.dolog.invite)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REGISTER") && $sel(cfg_get.dolog.register)) {
        $dlg_var(log) = "1";
    }

    if (is_method("PUBLISH") && $sel(cfg_get.dolog.publish)) {
        $dlg_var(log) = "1";
    }

    if (is_method("SUBSCRIBE") && $sel(cfg_get.dolog.subscribe)) {
        $dlg_var(log) = "1";
    }

    if (is_method("NOTIFY") && $sel(cfg_get.dolog.notify)) {
        $dlg_var(log) = "1";
    }

    if (is_method("OPTIONS") && $sel(cfg_get.dolog.options)) {
        $dlg_var(log) = "1";
    }

    if (is_method("MESSAGE") && $sel(cfg_get.dolog.message)) {
        $dlg_var(log) = "1";
    }

    if (is_method("REFER") && $sel(cfg_get.dolog.refer)) {
        $dlg_var(log) = "1";
    }

    # Needed variables
    if ($dlg_var(cidhash) == $null) {
        # Extract brandId (if present)
        if (is_present_hf('X-Info-BrandId')) {
            $dlg_var(brandId) = $hdr(X-Info-BrandId);
        } else if (lookup_domain("$fd")) {
            # If X-Info-BrandId not present, UAC talking
            # Guess brandId from domain :)
            $dlg_var(brandId) = $avp(brandId);
        }

        # Calculate callid hash
        $dlg_var(cidhash) = $(ci{s.md5}{s.substr,0,8});
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Calculated hash for $ci\n");
    }

    return;
}

route[RELATE_LEGS] {
    if ($sht(dialogs=>$dlg_var(xcallid)::source_ip) != '') {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELATE-LEGS: $ci aleg is $dlg_var(xcallid), set FLT-ISBLEG\n");
        setflag(FLT_ISBLEG);
        $sht(dialogs=>$ci::aleg) = $dlg_var(xcallid);

        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELATE-LEGS: $dlg_var(xcallid) bleg is $ci\n");
        $sht(dialogs=>$dlg_var(xcallid)::bleg) = $ci;
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RELATE-LEGS: $dlg_var(xcallid) not present in dialogs htable, skip\n");
    }
}

route[DIALOGS_GET_INFO] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-GET-INFO: Set source_ip to $si\n");
    $sht(dialogs=>$ci::source_ip) = $si;

    if (sdp_content()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-GET-INFO: Has SDP, check por m= and c= lines\n");

        if(sdp_get_line_startswith("$avp(cline)", "c=")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-GET-INFO: Set media_ip to $(avp(cline){s.select,2, })\n");
            $sht(dialogs=>$ci::media_ip) = $(avp(cline){s.select,2, });
        }

        if (sdp_get_line_startswith("$avp(mline)", "m=")) {
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-GET-INFO: Set media_port to $(avp(mline){s.select,1, })\n");
            $sht(dialogs=>$ci::media_port) = $(avp(mline){s.select,1, });
        }
    }
}

route[DIALOGS_COPY_INFO] {
    # If aleg found for this dialog, copy keys from each one to another
    if (isflagset(FLT_ISBLEG)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-COPY-INFO: aleg found for $ci, copy remote keys and vice versa\n");
        $avp(aleg) = $sht(dialogs=>$ci::aleg);
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-COPY-INFO: aleg not found for $ci, return\n");
        return;
    }

    # Copy leg1 ($avp(aleg)) info to leg2 ($ci) with remote prefix
    $sht(dialogs=>$ci::remote_source_ip) = $sht(dialogs=>$avp(aleg)::source_ip);
    $sht(dialogs=>$ci::remote_media_ip) = $sht(dialogs=>$avp(aleg)::media_ip);
    $sht(dialogs=>$ci::remote_media_port) = $sht(dialogs=>$avp(aleg)::media_port);

    # Copy leg2 ($ci) info to leg1 ($avp(aleg)) with remote prefix
    $sht(dialogs=>$avp(aleg)::remote_source_ip) = $sht(dialogs=>$ci::source_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_ip) = $sht(dialogs=>$ci::media_ip);
    $sht(dialogs=>$avp(aleg)::remote_media_port) = $sht(dialogs=>$ci::media_port);

    # Try to guest if directmedia seems possible
    if ($sht(dialogs=>$ci::source_ip) == $sht(dialogs=>$ci::remote_source_ip)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-COPY-INFO: Source IP of both endpoints is equal, directmedia seems legit\n");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] DIALOGS-COPY-INFO: Source IP of both endpoints is NOT equal, directmedia NOT possible\n");
    }
}

route[ACCOUNTING] {
    # Set accounting flags
    setflag(FLT_ACC);
    setflag(FLT_ACCFAILED); # even if the transaction fails

    # Set proxy value
    $dlg_var(proxy) = 'USER';

    # Where is my caller? Order: PAI, RPID, From
    # Note: In UAC->AS, caller will be overriden with user extension
    if (is_present_hf("P-Asserted-Identity")) {
        $dlg_var(caller) = $(ai{uri.user});
    } else if (is_present_hf("remote-party-id")) {
        $dlg_var(caller) = $(re{uri.user});
    } else {
        $dlg_var(caller) = $fU;
    }

    $dlg_var(callee) = $rU; # In AS->UAC, callee will be overriden with X-Info-Callee
    $dlg_var(callid) = $ci;
    if (is_present_hf("Diversion"))
        $dlg_var(diversion) = $(di{uri.user});

    if (is_present_hf("Referred-by")) {
        $dlg_var(referrer) = $(hdr(Referred-by){nameaddr.uri}{uri.user});
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] ACCOUNTING: Call due to bxfer from $dlg_var(referrer)\n");
    }
}

# Reply generic route (all replies goes through this route)
onreply_route {
    if ($dlg_var(log)) xlog("L_NOTICE", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Response: '$rs $rr' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ( $rm =~ $sel(cfg_get.dolog.printmsg_methods) ) xlog("L_WARN", "Received reply:\n\n$mb\n");

    if (is_method("PUBLISH") && ds_is_from_list("1")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Drop '$rs $rr' from AS to PUBLISH\n");
        drop;
    }
}

# Reply generic route (additional, for all replies)
onreply_route[MANAGE_REPLY] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: Additional for all replies\n");

    # Account user's missed calls if ringing
    if (is_method("INVITE") && $rs=="180" && !ds_is_from_list("1")) {
        setflag(FLT_ACCMISSED);
    }

    # Create Redis object
    if (is_method("INVITE") && !has_totag() && $rs =~ "1[0-9][0-9]") {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: Create redis object with initial data\n");
        redis_cmd("redis", "HMSET $dlg_var(redisset) status $rr AoR $dlg_var(AoR) interlocutor $dlg_var(interlocutor) applicationserver $sht(dialogs=>$ci::applicationserver)", "r");
        # Avoid multiple provisional responses to update create-time
        redis_cmd("redis", "HSETNX $dlg_var(redisset) create-time $TS", "r");
    }

    # Manage NAT
    if ($rs =~ "[12][0-9][0-9]") {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: Non-error reply $rs, call NATMANAGE\n");
        route(NATMANAGE);
    }

    # Manage WS
    if (nat_uac_test(64)) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_REPLY: add_contact_alias\n");
        # Do NAT traversal stuff for replies to a WebSocket connection
        # - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        add_contact_alias();
    }
}

failure_route[MANAGE_FAILURE] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: Call NATMANAGE\n");
    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE: t_is_canceled, exit here\n");
        exit;
    }
}

failure_route[MANAGE_FAILURE_AS] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: $rm FAILED: '$T_reply_code $T_reply_reason' to '$cs $rm' from '$fu' ($si:$sp) [$proto]\n");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Call NATMANAGE\n");
    route(NATMANAGE);

    if (t_is_canceled()) {
        if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: t_is_canceled, exit here\n");
        exit;
    }

    # next DST - only for 404 or local timeout
    if (t_check_status("404") or (t_branch_timeout() and !t_branch_replied())) {
        # Invalidate AS only if no response received
        if (t_branch_timeout() and !t_branch_replied()) {
            if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: Mark AS as inactive\n");
            ds_mark_dst("ip");
        }

        if(ds_next_dst()) {
            t_on_failure("MANAGE_FAILURE_AS");
            if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: going to <$ru> via <$du>\n");
            route(RELAY);
            exit;
        } else {
            if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No more AS-s available\n");
            exit;
        }
    }

    # AS responde algo inesperado, abortamos failover y enviamos 408 Timeout
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-FAILURE-AS: No failover for '$T_reply_code $T_reply_reason', forward reply\n");
    exit;
}

# Route for branching: Only for INVITEs and BYEs (fork-able)
branch_route[MANAGE_BRANCH] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE_BRANCH: NEW BRANCH [$T_branch_idx] to $du (R-URI: $ru)\n");

    route(TRANSPORT_DETECT);

    # Manage NAT
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] MANAGE-BRANCH: Call NATMANAGE\n");
    route(NATMANAGE);
}

# Executed when dialog fails with +3XX response code
event_route[dialog:failed] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog-failed: Delete $dlg_var(redisset) redis object\n");
    redis_cmd("redis", "DEL $dlg_var(redisset)", "r");
}

# Executed when dialog is confirmed with 2XX response code
event_route[dialog:start] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog-start: Update $dlg_var(redisset) redis object status to established\n");
    redis_cmd("redis", "HMSET $dlg_var(redisset) status established establish-time $TS", "r");

    if(isbflagset(FLB_WEBSOCKETS)) {
        if ($dlg_var(log)) xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Answered dialog involves websockets\n");
        $dlg_var(ws) = 'yes';
    }

    if (!ds_is_from_list("1")) {
        # Call to DIALOGS_GET_INFO and DIALOGS_COPY_INFO only for 200 OK from UACs
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Invoke DIALOGS_GET_INFO for 200 OK from UAC ($ci)\n");
        route(DIALOGS_GET_INFO);
        route(DIALOGS_COPY_INFO);
    }

    if ($dlg_var(profile) != $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) established for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
        route(PRINT_STATS);
    }
}

# Executed when dialog is ended with BYE or timeout
event_route[dialog:end] {
    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] dialog-end: Delete $dlg_var(redisset) redis object\n");
    redis_cmd("redis", "DEL $dlg_var(redisset)", "r");

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Dialog ended, delete keys from dialogs htable starting with $ci\n");
    sht_rm_name_re("dialogs=>$ci::.*");

    if ($dlg_var(profile) != $null) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] PRINT-STATS: $dlg_var(profile) ended for '$dlg_var(companyName)' (id: $dlg_var(companyId)) [$ci]\n");
        route(PRINT_STATS);
    }
}

onsend_route {
    if ($rm =~ $sel(cfg_get.dolog.printmsg_methods)) {
        if (is_request())
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent request:\n\n$snd(buf)\n");
        else
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Sent reply:\n\n$snd(buf)\n");
    }
}

route[XMLRPC]{
    if ($Rp != XMLRPC_PORT) {
        if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_WARN", "XMLRPC: request received on $Rp, forbidden\n");
        xmlrpc_reply("400", "Unauthorized");
        exit;
    }

    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: XMLRPC call from $si:$sp to $Rp, proceed\n");

    # Ejemplo de lo que recibo de RTPengine:
    #    POST /RPC2 HTTP/1.1.
    #    Host: 5.196.32.135:5060.
    #    Accept: */*.
    #    Content-Type: text/xml.
    #    User-Agent: Xmlrpc-c/1.33.14 Curl/7.38.0.
    #    Content-Length: 210.
    #
    #    <?xml version="1.0" encoding="UTF-8"?>
    #    <methodCall>
    #    <methodName>teardown</methodName>
    #    <params>
    #    <param><value><string>9c7bc06a-5d29-4bf0-8b89-faafd3da4f50</string></value></param>
    #    </params>
    #    </methodCall>

    # √ëapa del siglo para extraer de ese POST algo XML-alike para luego parsearlo con xmlops
    $var(x) = $(mb{s.select,-1,?}); # Busco la ultima '?' y me quedo de ahi en adelante
    $xml(x=>doc) = $(var(x){s.substr,1,0}); # Me quito '>\n' del principio y lo que queda es XML-alike

    # Extraigo methodName
    $var(methodName) = $xml(x=>xpath:/methodCall/methodName/text());
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_NOTICE", "XMLRPC: methodName: $var(methodName)\n");

    # Llamo a la ruta adecuada en funcion del comando
    if ($var(methodName) == "teardown")
        route(RTPTIMEOUT);
    else
        route(GENERIC_XMLRPC_COMMAND);
}

route[GENERIC_XMLRPC_COMMAND] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "GENERIC_XMLRPC_COMMAND: XMLRPC generic command from allowed IP ($si), dispatch!\n");

    # close connection only for xmlrpclib user agents
    if search("^User-Agent:.*xmlrpclib")
        set_reply_close();
    set_reply_no_connect(); # optional
    dispatch_rpc();
}

route[RTPTIMEOUT] {
    if ($sel(cfg_get.dolog.xmlrpc)) xlog("L_INFO", "RTPTIMEOUT: RTPengine wants to hangup a call\n");
    $var(callid) = $xml(x=>xpath:/methodCall/params/param/value/string/text());
    $var(fromtag) = $sht(dialogs=>$var(callid)::from_tag);

    # Logica que obtiene $var(h_entry) y $var(h_id) partiendo de $var(callid) y del from_tag guardado en htable(dialogs)
    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.dlg_list" , "params" : [ "$var(callid)" , "$var(fromtag)" ], "id" : 1}');
    $var(json) = $jsonrpl(body);

    # Extraemos json del resultado
    json_get_field("$var(json)", "result", "$var(result)");
    json_get_field("$var(result)", "h_entry", "$var(h_entry)");

    # Extraemos h_entry y h_id
    json_get_field("$var(result)", "h_id", "$var(h_id)");

    # Matamos dialogo con ese h_entry y ese h_id
    jsonrpc_exec('{ "jsonrpc" : "2.0" , "method" : "dlg.end_dlg" , "params" : [ $var(h_entry) , $var(h_id) ], "id" : 2 }');

    if ($sel(cfg_get.dolog.xmlrpc)) {
        if ($jsonrpl(code) == "200") {
            xlog("L_INFO", "RTPTIMEOUT: Dialog ended: $jsonrpl(code) $jsonrpl(text)\n");
        } else {
            xlog("L_ERR", "RTPTIMEOUT: Problems killing dialog: $jsonrpl(code) $jsonrpl(text)\n");
        }
    }

    xmlrpc_reply("200", "Thanks for all the fish");

    return;
}

route[TRANSPORT_DETECT] {
    if (!is_method("INVITE")) return;

    if (is_request() && !has_totag()) {
        if ($rP == 'ws' || $rP == 'wss' || $proto == 'ws' || $proto == 'wss') {
            xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] TRANSPORT-DETECT: Websockets, set FLB_WEBSOCKETS\n");
            setbflag(FLB_WEBSOCKETS);
        }
    }
}

route[RTPRELAY] {
    if (!is_method("INVITE|UPDATE|ACK|BYE|CANCEL")) return;

    if ($dlg_var(ws) == 'yes' || isbflagset(FLB_WEBSOCKETS)) {
        xlog("L_WARN", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPRELAY: Websockets around, call rtpengine\n");
        route(RTPENGINE);
    } else {
        route(RTPPROXY);
    }
}

route[RTPPROXY] {
    if ($(dlg_var(mediaRelaySetsId){s.len}) > 0 && $dlg_var(mediaRelaySetsId) != 0) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Custom rtpproxy set: $dlg_var(mediaRelaySetsId)\n");
        set_rtp_proxy_set("$(dlg_var(mediaRelaySetsId){s.int})");
    }

    if (has_body("application/sdp") && nat_uac_test("8")) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Private IPs in SDP found, do not trust SDP addresses\n");
        rtpproxy_manage("cowf");
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: No private IPs in SDP, trust SDP addresses\n");
        rtpproxy_manage("coarf");
    }

    if (is_request() && is_method("INVITE") && !has_totag()) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPPROXY: Chosen RTPproxy instance $var(RTP_INSTANCE)\n");
    }
}

route[RTPENGINE] {
    $var(common_opts) = 'replace-session-connection replace-origin force';

    if (has_body("application/sdp") && nat_uac_test("8")) {
        $var(symmetry) = 'symmetric SIP-source-address';
    } else {
        $var(symmetry) = 'asymmetric trust-address';
    }

    if ($proto == 'ws' || $proto == 'wss' ) {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto, convert to udp\n");
        $var(wsopts) = 'ICE=remove RTP/AVP DTLS=no';
    } else {
        if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: Is through $proto (non-ws), convert to wss\n");
        $var(wsopts) = 'ICE=force RTP/SAVPF DTLS=passive';
    }

    if ($dlg_var(log)) xlog("L_INFO", "[b$dlg_var(brandId)][$dlg_var(cidhash)] RTPENGINE: rtpengine_manage [$var(common_opts) $var(symmetry) $var(wsopts)]\n");
    rtpengine_manage("$var(common_opts) $var(symmetry) $var(wsopts)");
}

event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();

    if ($Rp == WS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTP Request Received from $si:$sp\n");
    } else if ($Rp == WSS_PORT) {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "HTTPS Request Received from $si:$sp\n");
    } else {
        if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received on $Rp, port not allowed\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    if ($hdr(Upgrade)=~"websocket" && $hdr(Connection)=~"Upgrade" && $rm=~"GET") {
        # Validate Host - make sure the client is using the correct
        # alias for WebSockets
        # if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
        #     if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Bad host $hdr(Host)\n");
        #     xhttp_reply("403", "Forbidden, bad host", "", "");
        #     exit;
        # }

        # Optional... validate Origin - make sure the client is from an
        # authorised website.  For example,
        #
        # if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
        #     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
        #       if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
        #       xhttp_reply("403", "Forbidden", "", "");
        #       exit;
        # }

        # Optional... perform HTTP authentication

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake()) {
            # Optional... cache some information about the
            # successful connection
            if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "Connection upgrade to websocket was successful\n");
            exit;
        }
    }

    if ($sel(cfg_get.dolog.websocket)) xlog("L_WARN", "HTTP(S) request received without Upgrade to Websocket header, 404\n");
    xhttp_reply("404", "Not found", "", "");
}

event_route[websocket:closed] {
    if ($sel(cfg_get.dolog.websocket)) xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}

event_route[dispatcher:dst-down] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Destination down: $rm $ru ($du)\n");
}

event_route[dispatcher:dst-up] {
    if ($dlg_var(log)) xlog("L_ERR", "[b$dlg_var(brandId)][$dlg_var(cidhash)] Destination up: $rm $ru\n");
}

